#!/usr/bin/env bash
set -euo pipefail

# Send prompt to ChatGPT via the already-open ChatGPT Web tab (visible Chrome),
# using Chrome DevTools Protocol (CDP) to type/click and then scrape the final
# assistant response back to the terminal.

# Root folder for tool state.
# Default is the repo root (relative to this script), but can be overridden.
#
# NOTE: Users often put `chatgpt_send` on PATH via a symlink (e.g. ~/.local/bin).
# If we used BASH_SOURCE[0] directly, we'd treat ~/.local as the root and break
# relative paths like bin/chrome_no_sandbox. So we resolve symlinks first.
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
  _dir="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
  SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
  [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$_dir/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
ROOT_DEFAULT="$(cd "${SCRIPT_DIR}/.." && pwd)"
ROOT="${CHATGPT_SEND_ROOT:-$ROOT_DEFAULT}"
# This tool stores browser profile data and session metadata under ROOT/state/.
# Default to private permissions for any newly created files/dirs (override if needed).
umask "${CHATGPT_SEND_UMASK:-077}"

PROMPT=""
PROMPT_FILE=""
MODEL="gpt-5.2-pro"         # only used to target a picker label; we keep current model by default.
MODEL_STRATEGY="current"    # respect whatever model is selected in the open ChatGPT UI.
KEEP_BROWSER=1
MANUAL_LOGIN=1
PROFILE_DIR_DEFAULT="$ROOT/state/manual-login-profile"
PROFILE_DIR="${CHATGPT_SEND_PROFILE_DIR:-$PROFILE_DIR_DEFAULT}"
CHROME_PATH="$ROOT/bin/chrome_no_sandbox"
CHATGPT_URL=""
CHATGPT_URL_EXPLICIT=0
CHATGPT_URL_FILE="$ROOT/state/chatgpt_url.txt"
WORK_CHAT_URL_FILE="$ROOT/state/work_chat_url.txt"
CHATS_DB="$ROOT/state/chats.json"
CHATS_MD="$ROOT/state/sessions.md"
ACK_DB="$ROOT/state/ack.json"
PROTOCOL_LOG="$ROOT/state/protocol.jsonl"
LAST_SPECIALIST_CHECKPOINT_FILE="$ROOT/state/last_specialist_checkpoint.json"
CHAT_URL_SOURCE="unset"
TIMEOUT="auto"
DRY_RUN=0
OPEN_BROWSER=0
PRINT_URL=0
SYNC_URL=0
CDP_PORT="${CHATGPT_SEND_CDP_PORT:-9222}"
LIST_CHATS=0
INIT_SPECIALIST=0
INIT_TOPIC=""
INIT_SESSION_NAME=""
INIT_SESSION_TITLE=""
SET_ACTIVE_TITLE=""
DOCTOR=0
DOCTOR_JSON=0
DO_CLEANUP=0
DO_GRACEFUL_RESTART=0
DO_ACK=0
SAVE_CHAT_NAME=""
USE_CHAT_NAME=""
DELETE_CHAT_NAME=""
BUNDLE_RUN_ID=""
LOOP_INIT=""
LOOP_STATUS=0
LOOP_INC=0
LOOP_CLEAR=0
PRESERVE_TABS="${CHATGPT_SEND_PRESERVE_TABS:-0}"
AUTO_TAB_HYGIENE="${CHATGPT_SEND_AUTO_TAB_HYGIENE:-0}"

ATTACH=()
ORIG_ARGS=("$@")
LOCK_FILE="${CHATGPT_SEND_LOCK_FILE:-}"
LOCK_TIMEOUT_SEC="${CHATGPT_SEND_LOCK_TIMEOUT_SEC:-120}"
LOCK_HELD="${CHATGPT_SEND_LOCK_HELD:-0}"
RUN_ID="${CHATGPT_SEND_RUN_ID:-run-$(date +%s)-$$}"
LOG_DIR="${CHATGPT_SEND_LOG_DIR:-}"
WAIT_ONLY="${CHATGPT_SEND_WAIT_ONLY:-0}"
SKIP_PRECHECK="${CHATGPT_SEND_SKIP_PRECHECK:-0}"
AUTO_WAIT_ON_GENERATION="${CHATGPT_SEND_AUTO_WAIT_ON_GENERATION:-1}"
AUTO_WAIT_MAX_SEC="${CHATGPT_SEND_AUTO_WAIT_MAX_SEC:-60}"
AUTO_WAIT_POLL_MS="${CHATGPT_SEND_AUTO_WAIT_POLL_MS:-500}"
REPLY_POLLING="${CHATGPT_SEND_REPLY_POLLING:-1}"
REPLY_POLL_MS="${CHATGPT_SEND_REPLY_POLL_MS:-700}"
REPLY_MAX_SEC="${CHATGPT_SEND_REPLY_MAX_SEC:-90}"
REPLY_NO_PROGRESS_MAX_MS="${CHATGPT_SEND_REPLY_NO_PROGRESS_MAX_MS:-45000}"
LATE_REPLY_GRACE_SEC="${CHATGPT_SEND_LATE_REPLY_GRACE_SEC:-30}"
LATE_REPLY_POLL_MS="${CHATGPT_SEND_LATE_REPLY_POLL_MS:-1500}"
LATE_REPLY_STABLE_TICKS="${CHATGPT_SEND_LATE_REPLY_STABLE_TICKS:-2}"
STRICT_UI_CONTRACT="${CHATGPT_SEND_STRICT_UI_CONTRACT:-0}"
CAPTURE_EVIDENCE="${CHATGPT_SEND_CAPTURE_EVIDENCE:-1}"
SANITIZE_LOGS="${CHATGPT_SEND_SANITIZE_LOGS:-1}"
PROTECT_CHAT_URL="${CHATGPT_SEND_PROTECT_CHAT_URL:-}"
REQUIRE_CONVO_URL="${CHATGPT_SEND_REQUIRE_CONVO_URL:-1}"
ALLOW_HOME_SEND="${CHATGPT_SEND_ALLOW_HOME_SEND:-0}"
ENFORCE_ACTIVE_PIN_MATCH="${CHATGPT_SEND_ENFORCE_ACTIVE_PIN_MATCH:-0}"
STRICT_SINGLE_CHAT="${CHATGPT_SEND_STRICT_SINGLE_CHAT:-1}"
STRICT_SINGLE_CHAT_ACTION="${CHATGPT_SEND_STRICT_SINGLE_CHAT_ACTION:-block}"
FETCH_LAST_N="${CHATGPT_SEND_FETCH_LAST_N:-6}"
FETCH_LAST_REQUIRED="${CHATGPT_SEND_FETCH_LAST_REQUIRED:-1}"
NO_BLIND_RESEND="${CHATGPT_SEND_NO_BLIND_RESEND:-1}"
PROTO_ENFORCE_FINGERPRINT="${CHATGPT_SEND_PROTO_ENFORCE_FINGERPRINT:-0}"
PROTO_ENFORCE_POSTSEND_VERIFY="${CHATGPT_SEND_PROTO_ENFORCE_POSTSEND_VERIFY:-0}"
POSTSEND_VERIFY_FETCH_LAST_N="${CHATGPT_SEND_POSTSEND_VERIFY_FETCH_LAST_N:-4}"
PROTOCOL_LOCK_FILE="${CHATGPT_SEND_PROTOCOL_LOCK_FILE:-$ROOT/state/protocol.lock}"
CHECKPOINT_LOCK_FILE="${CHATGPT_SEND_CHECKPOINT_LOCK_FILE:-$ROOT/state/checkpoint.lock}"
CHAT_SINGLE_FLIGHT="${CHATGPT_SEND_CHAT_SINGLE_FLIGHT:-1}"
CHAT_SINGLE_FLIGHT_LOCK_DIR="${CHATGPT_SEND_CHAT_LOCK_DIR:-$ROOT/state/locks}"
CHAT_SINGLE_FLIGHT_TIMEOUT_SEC="${CHATGPT_SEND_CHAT_LOCK_TIMEOUT_SEC:-20}"
CDP_RECOVER_LOCK_FILE="${CHATGPT_SEND_CDP_RECOVER_LOCK_FILE:-/tmp/chatgpt-send-cdp-recover.lock}"
CDP_RECOVER_LAST_TS_FILE="${CHATGPT_SEND_CDP_RECOVER_LAST_TS_FILE:-/tmp/chatgpt-send-cdp-recover.last}"
CDP_RECOVER_COOLDOWN_SEC="${CHATGPT_SEND_CDP_RECOVER_COOLDOWN_SEC:-2}"
CDP_RECOVER_LOCK_TIMEOUT_SEC="${CHATGPT_SEND_CDP_RECOVER_LOCK_TIMEOUT_SEC:-30}"
CDP_RECOVER_BUDGET="${CHATGPT_SEND_CDP_RECOVER_BUDGET:-1}"
CDP_RECOVER_USED=0
RESTART_RECOMMEND_UPTIME_SEC="${CHATGPT_SEND_RESTART_RECOMMEND_UPTIME_SEC:-14400}"
ALLOW_BROWSER_RESTART="${CHATGPT_SEND_ALLOW_BROWSER_RESTART:-0}"
TIMEOUT_BUDGET_WINDOW_SEC="${CHATGPT_SEND_TIMEOUT_BUDGET_WINDOW_SEC:-300}"
TIMEOUT_BUDGET_MAX="${CHATGPT_SEND_TIMEOUT_BUDGET_MAX:-3}"
TIMEOUT_BUDGET_ACTION="${CHATGPT_SEND_TIMEOUT_BUDGET_ACTION:-restart}"
NORM_VERSION="${CHATGPT_SEND_NORM_VERSION:-v1}"
ENFORCE_ITERATION_PREFIX="${CHATGPT_SEND_ENFORCE_ITERATION_PREFIX:-1}"

LIB_CHATGPT_SEND_DIR="$SCRIPT_DIR/lib/chatgpt_send"
if [[ ! -r "$LIB_CHATGPT_SEND_DIR/core.sh" ]] || [[ ! -r "$LIB_CHATGPT_SEND_DIR/runtime.sh" ]] || [[ ! -r "$LIB_CHATGPT_SEND_DIR/argparse.sh" ]] || [[ ! -r "$LIB_CHATGPT_SEND_DIR/commands.sh" ]] || [[ ! -r "$LIB_CHATGPT_SEND_DIR/send_pipeline.sh" ]] || [[ ! -r "$LIB_CHATGPT_SEND_DIR/main_flow.sh" ]]; then
  fallback_lib_dir="$ROOT/bin/lib/chatgpt_send"
  if [[ -r "$fallback_lib_dir/core.sh" ]] && [[ -r "$fallback_lib_dir/runtime.sh" ]] && [[ -r "$fallback_lib_dir/argparse.sh" ]] && [[ -r "$fallback_lib_dir/commands.sh" ]] && [[ -r "$fallback_lib_dir/send_pipeline.sh" ]] && [[ -r "$fallback_lib_dir/main_flow.sh" ]]; then
    LIB_CHATGPT_SEND_DIR="$fallback_lib_dir"
  else
    echo "Missing chatgpt_send modules in $LIB_CHATGPT_SEND_DIR and $fallback_lib_dir" >&2
    exit 2
  fi
fi
# Load modular function blocks (keeps top-level flow readable).
# shellcheck source=/dev/null
source "$LIB_CHATGPT_SEND_DIR/core.sh"
# shellcheck source=/dev/null
source "$LIB_CHATGPT_SEND_DIR/runtime.sh"
# shellcheck source=/dev/null
source "$LIB_CHATGPT_SEND_DIR/argparse.sh"
# shellcheck source=/dev/null
source "$LIB_CHATGPT_SEND_DIR/commands.sh"
# shellcheck source=/dev/null
source "$LIB_CHATGPT_SEND_DIR/send_pipeline.sh"
# shellcheck source=/dev/null
source "$LIB_CHATGPT_SEND_DIR/main_flow.sh"


if [[ -n "${LOCK_FILE:-}" ]] && [[ "${LOCK_HELD}" != "1" ]]; then
  mkdir -p "$(dirname "$LOCK_FILE")" >/dev/null 2>&1 || true
  if command -v flock >/dev/null 2>&1; then
    lock_run_id="${CHATGPT_SEND_LOCK_RUN_ID:-lock-$(date +%s)-$$}"
    _now_ms() { date +%s%3N 2>/dev/null || python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
}
    lock_wait_start_ms="$(_now_ms)"
    exec {lock_fd}>"$LOCK_FILE"
    set +e
    flock -x -w "$LOCK_TIMEOUT_SEC" -E 75 "$lock_fd"
    lock_acq_st=$?
    set -e
    lock_acq_ms="$(_now_ms)"
    lock_wait_ms=$((lock_acq_ms - lock_wait_start_ms))
    echo "[LOCK] event=acquire_attempt run_id=${lock_run_id} lock_file=${LOCK_FILE} wait_ms=${lock_wait_ms}" >&2
    if [[ $lock_acq_st -ne 0 ]]; then
      exec {lock_fd}>&- || true
      if [[ $lock_acq_st -eq 75 ]]; then
        echo "[E_LOCK_TIMEOUT] Failed to acquire chatgpt_send lock within ${LOCK_TIMEOUT_SEC}s: $LOCK_FILE" >&2
        export CHATGPT_SEND_ERROR_CODE="E_LOCK_TIMEOUT"
        exit 70
      fi
      exit $lock_acq_st
    fi
    export CHATGPT_SEND_LOCK_HELD=1
    export CHATGPT_SEND_LOCK_RUN_ID="$lock_run_id"
    set +e
    "$SCRIPT_PATH" "${ORIG_ARGS[@]}"
    lock_st=$?
    set -e
    lock_rel_ms="$(_now_ms)"
    lock_held_ms=$((lock_rel_ms - lock_acq_ms))
    echo "[LOCK] event=release run_id=${lock_run_id} lock_file=${LOCK_FILE} lock_held_ms=${lock_held_ms}" >&2
    flock -u "$lock_fd" >/dev/null 2>&1 || true
    exec {lock_fd}>&- || true
    if [[ $lock_st -ne 0 ]]; then
      exit $lock_st
    fi
    exit $lock_st
  else
    echo "Warning: CHATGPT_SEND_LOCK_FILE is set but flock is unavailable; running without lock." >&2
  fi
fi


run_chatgpt_send_main "$@"
