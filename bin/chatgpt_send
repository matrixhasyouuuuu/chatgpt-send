#!/usr/bin/env bash
set -euo pipefail

# Send prompt to ChatGPT via the already-open ChatGPT Web tab (visible Chrome),
# using Chrome DevTools Protocol (CDP) to type/click and then scrape the final
# assistant response back to the terminal.

# Root folder for tool state.
# Default is the repo root (relative to this script), but can be overridden.
#
# NOTE: Users often put `chatgpt_send` on PATH via a symlink (e.g. ~/.local/bin).
# If we used BASH_SOURCE[0] directly, we'd treat ~/.local as the root and break
# relative paths like bin/chrome_no_sandbox. So we resolve symlinks first.
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
  _dir="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
  SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
  [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$_dir/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
ROOT_DEFAULT="$(cd "${SCRIPT_DIR}/.." && pwd)"
ROOT="${CHATGPT_SEND_ROOT:-$ROOT_DEFAULT}"
# This tool stores browser profile data and session metadata under ROOT/state/.
# Default to private permissions for any newly created files/dirs (override if needed).
umask "${CHATGPT_SEND_UMASK:-077}"

PROMPT=""
PROMPT_FILE=""
MODEL="gpt-5.2-pro"         # only used to target a picker label; we keep current model by default.
MODEL_STRATEGY="current"    # respect whatever model is selected in the open ChatGPT UI.
KEEP_BROWSER=1
MANUAL_LOGIN=1
PROFILE_DIR_DEFAULT="$ROOT/state/manual-login-profile"
PROFILE_DIR="${CHATGPT_SEND_PROFILE_DIR:-$PROFILE_DIR_DEFAULT}"
CHROME_PATH="$ROOT/bin/chrome_no_sandbox"
CHATGPT_URL=""
CHATGPT_URL_EXPLICIT=0
CHATGPT_URL_FILE="$ROOT/state/chatgpt_url.txt"
CHATS_DB="$ROOT/state/chats.json"
CHATS_MD="$ROOT/state/sessions.md"
TIMEOUT="auto"
DRY_RUN=0
OPEN_BROWSER=0
PRINT_URL=0
SYNC_URL=0
CDP_PORT="${CHATGPT_SEND_CDP_PORT:-9222}"
LIST_CHATS=0
INIT_SPECIALIST=0
INIT_TOPIC=""
INIT_SESSION_NAME=""
INIT_SESSION_TITLE=""
SET_ACTIVE_TITLE=""
DOCTOR=0
SAVE_CHAT_NAME=""
USE_CHAT_NAME=""
DELETE_CHAT_NAME=""
LOOP_INIT=""
LOOP_STATUS=0
LOOP_INC=0
LOOP_CLEAR=0
PRESERVE_TABS="${CHATGPT_SEND_PRESERVE_TABS:-0}"

ATTACH=()
ORIG_ARGS=("$@")
LOCK_FILE="${CHATGPT_SEND_LOCK_FILE:-}"
LOCK_TIMEOUT_SEC="${CHATGPT_SEND_LOCK_TIMEOUT_SEC:-120}"
LOCK_HELD="${CHATGPT_SEND_LOCK_HELD:-0}"
RUN_ID="${CHATGPT_SEND_RUN_ID:-run-$(date +%s)-$$}"
LOG_DIR="${CHATGPT_SEND_LOG_DIR:-}"
WAIT_ONLY="${CHATGPT_SEND_WAIT_ONLY:-0}"
SKIP_PRECHECK="${CHATGPT_SEND_SKIP_PRECHECK:-0}"
AUTO_WAIT_ON_GENERATION="${CHATGPT_SEND_AUTO_WAIT_ON_GENERATION:-1}"
AUTO_WAIT_MAX_SEC="${CHATGPT_SEND_AUTO_WAIT_MAX_SEC:-60}"
AUTO_WAIT_POLL_MS="${CHATGPT_SEND_AUTO_WAIT_POLL_MS:-500}"
REPLY_POLLING="${CHATGPT_SEND_REPLY_POLLING:-1}"
REPLY_POLL_MS="${CHATGPT_SEND_REPLY_POLL_MS:-700}"
REPLY_MAX_SEC="${CHATGPT_SEND_REPLY_MAX_SEC:-90}"
REQUIRE_CONVO_URL="${CHATGPT_SEND_REQUIRE_CONVO_URL:-1}"
ALLOW_HOME_SEND="${CHATGPT_SEND_ALLOW_HOME_SEND:-0}"
ENFORCE_ACTIVE_PIN_MATCH="${CHATGPT_SEND_ENFORCE_ACTIVE_PIN_MATCH:-1}"
CDP_RECOVER_LOCK_FILE="${CHATGPT_SEND_CDP_RECOVER_LOCK_FILE:-/tmp/chatgpt-send-cdp-recover.lock}"
CDP_RECOVER_LAST_TS_FILE="${CHATGPT_SEND_CDP_RECOVER_LAST_TS_FILE:-/tmp/chatgpt-send-cdp-recover.last}"
CDP_RECOVER_COOLDOWN_SEC="${CHATGPT_SEND_CDP_RECOVER_COOLDOWN_SEC:-2}"
CDP_RECOVER_LOCK_TIMEOUT_SEC="${CHATGPT_SEND_CDP_RECOVER_LOCK_TIMEOUT_SEC:-30}"
CDP_RECOVER_BUDGET="${CHATGPT_SEND_CDP_RECOVER_BUDGET:-1}"
CDP_RECOVER_USED=0

usage() {
  cat <<'EOF'
Usage:
  chatgpt_send [options] (--prompt TEXT | --prompt-file PATH | < prompt.txt)
  chatgpt_send --init-specialist
  chatgpt_send --set-chatgpt-url URL
  chatgpt_send --clear-chatgpt-url
  chatgpt_send --show-chatgpt-url
  chatgpt_send --open-browser [--chatgpt-url URL]
  chatgpt_send --sync-chatgpt-url
  chatgpt_send --list-chats
  chatgpt_send --doctor
  chatgpt_send --save-chat NAME [--chatgpt-url URL]
  chatgpt_send --use-chat NAME
  chatgpt_send --delete-chat NAME
  chatgpt_send --set-active-title TEXT
  chatgpt_send --loop-init N
  chatgpt_send --loop-status
  chatgpt_send --loop-inc
  chatgpt_send --loop-clear

Options:
  --prompt TEXT
  --prompt-file PATH
  --model MODEL                 (default: gpt-5.2-pro)
  --model-strategy MODE         select|current|ignore (default: current)
  --keep-browser / --no-keep-browser
  --manual-login / --no-manual-login (default: manual-login)
  --chrome-path PATH            (default: bin/chrome_no_sandbox)
  --chatgpt-url URL
  --chat-id ID                  shortcut for https://chatgpt.com/c/ID
  --init-specialist             open browser (if needed) and send bootstrap prompt to create/pin a new Specialist chat
  --topic TEXT                  (with --init-specialist) short task/topic; used as first message and saved in sessions list
  --set-chatgpt-url URL         persist default chat URL (same chat every run)
  --clear-chatgpt-url           remove persisted default chat URL
  --show-chatgpt-url            print persisted/default chat URL and exit
  --open-browser                open the automation Chrome/profile and exit
  --sync-chatgpt-url            detect current chat URL from open tabs and persist it
  --print-chatgpt-url           print resolved URL to stderr on each run
  --list-chats                  list saved Specialist chats (name -> url)
  --doctor                      print a quick health report (CDP, pinned chat, sessions)
  --save-chat NAME              save current/resolved chat as NAME
  --use-chat NAME               switch active chat to NAME
  --delete-chat NAME            remove saved chat NAME
  --set-active-title TEXT       set the title for the active Specialist session (for easier session list browsing)
  --loop-init N                 set loop max iterations for active Specialist session (done=0)
  --loop-status                 show loop status for active session (done/max)
  --loop-inc                    increment loop done for active session (caps at max)
  --loop-clear                  clear loop state for active session
  (writes session list to state/sessions.md automatically)
  --cdp-port PORT               DevTools port for the shared Chrome (default: 9222)
  --timeout SECONDS|auto
  --attach PATH_OR_GLOB         (repeatable)
  --dry-run                     (do not open browser; shows preview)
EOF
}

resolve_timeout_seconds() {
  # TIMEOUT is either "auto" or a number of seconds.
  if [[ "${TIMEOUT:-auto}" == "auto" ]]; then
    # Default can be overridden via env for child-agent flows where hanging
    # for 15 minutes is too expensive.
    if [[ "${CHATGPT_SEND_AUTO_TIMEOUT_SEC:-}" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
      echo "${CHATGPT_SEND_AUTO_TIMEOUT_SEC}"
      return 0
    fi
    # Fallback default: give the web UI enough time, but don't hang forever.
    echo "900"
    return 0
  fi
  # Best-effort numeric parse; fallback to 900.
  if [[ "${TIMEOUT:-}" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
    echo "$TIMEOUT"
    return 0
  fi
  echo "900"
}

emit_wait_only_block() {
  local action="${1:-unknown}"
  echo "E_USER_REQUEST_WAIT_ONLY action=${action} run_id=${RUN_ID}" >&2
  exit 74
}

emit_target_chat_required() {
  local got="${1:-none}"
  echo "E_TARGET_CHAT_REQUIRED got=${got} run_id=${RUN_ID}" >&2
  exit 72
}

emit_chat_state_mismatch() {
  local active_url="${1:-none}"
  local pinned_url="${2:-none}"
  echo "E_CHAT_STATE_MISMATCH active_url=${active_url} pinned_url=${pinned_url} run_id=${RUN_ID}" >&2
  exit 72
}

log_action() {
  local action="$1"
  shift || true
  local extra="$*"
  if [[ -n "${extra//[[:space:]]/}" ]]; then
    echo "action=${action} run_id=${RUN_ID} ${extra}" >&2
  else
    echo "action=${action} run_id=${RUN_ID}" >&2
  fi
}

now_ms() {
  date +%s%3N 2>/dev/null || python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
}

cdp_is_up() {
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/version" >/dev/null 2>&1
}

is_chat_conversation_url() {
  # ChatGPT chat URLs look like: https://chatgpt.com/c/<uuid-ish>
  # We accept hex+hyphen IDs (what ChatGPT currently uses).
  local u="${1:-}"
  [[ "$u" =~ ^https://chatgpt\.com/c/[0-9a-fA-F-]{16,}$ ]]
}

wait_for_cdp() {
  # Wait up to ~6s for Chrome DevTools to become reachable.
  local i
  for i in {1..12}; do
    if cdp_is_up; then
      return 0
    fi
    sleep 0.5
  done
  return 1
}

cdp_recover_single_flight() {
  # Serialize CDP/browser recovery and apply a short cooldown to avoid
  # restart storms when several agents hit transient CDP errors together.
  local reason="$1"
  local url="$2"
  local cooldown now last wait_s recover_rc lock_fd
  cooldown="$CDP_RECOVER_COOLDOWN_SEC"
  if [[ ! "$cooldown" =~ ^[0-9]+$ ]]; then
    cooldown=2
  fi

  _recover_body() {
    now="$(date +%s)"
    last=0
    if [[ -f "$CDP_RECOVER_LAST_TS_FILE" ]]; then
      last="$(cat "$CDP_RECOVER_LAST_TS_FILE" 2>/dev/null | tr -d '[:space:]' || true)"
      [[ "$last" =~ ^[0-9]+$ ]] || last=0
    fi
    wait_s=0
    if (( cooldown > 0 )) && (( now > 0 )) && (( last > 0 )) && (( now - last < cooldown )); then
      wait_s=$((cooldown - (now - last)))
    fi
    if (( wait_s > 0 )); then
      echo "[P4] cdp_recover cooldown_wait=${wait_s}s reason=${reason} run_id=${RUN_ID}" >&2
      sleep "$wait_s"
    fi
    echo "[P4] cdp_recover single_flight reason=${reason} url=${url} run_id=${RUN_ID}" >&2
    open_browser_impl "$url"
    recover_rc=$?
    date +%s >"$CDP_RECOVER_LAST_TS_FILE" 2>/dev/null || true
    return "$recover_rc"
  }

  mkdir -p "$(dirname "$CDP_RECOVER_LOCK_FILE")" >/dev/null 2>&1 || true
  mkdir -p "$(dirname "$CDP_RECOVER_LAST_TS_FILE")" >/dev/null 2>&1 || true
  if command -v flock >/dev/null 2>&1; then
    exec {lock_fd}>"$CDP_RECOVER_LOCK_FILE" || return 1
    if flock -x -w "$CDP_RECOVER_LOCK_TIMEOUT_SEC" "$lock_fd"; then
      _recover_body
      recover_rc=$?
      flock -u "$lock_fd" >/dev/null 2>&1 || true
      exec {lock_fd}>&- || true
      return "$recover_rc"
    fi
    echo "E_CDP_RECOVER_LOCK_TIMEOUT reason=${reason} file=${CDP_RECOVER_LOCK_FILE} run_id=${RUN_ID}" >&2
    exec {lock_fd}>&- || true
    return 1
  fi
  _recover_body
}

maybe_cdp_recover() {
  local reason="$1"
  local url="$2"
  local budget="$CDP_RECOVER_BUDGET"
  if [[ ! "$budget" =~ ^[0-9]+$ ]]; then
    budget=1
  fi
  if (( CDP_RECOVER_USED >= budget )); then
    echo "E_CDP_RECOVER_BUDGET_EXCEEDED used=${CDP_RECOVER_USED} budget=${budget} reason=${reason} run_id=${RUN_ID}" >&2
    return 1
  fi
  cdp_recover_single_flight "$reason" "$url"
  local rc=$?
  if [[ $rc -eq 0 ]]; then
    CDP_RECOVER_USED=$((CDP_RECOVER_USED + 1))
    echo "[P4] cdp_recover used=${CDP_RECOVER_USED}/${budget} reason=${reason} run_id=${RUN_ID}" >&2
  fi
  return $rc
}

chrome_pids_for_profile() {
  # Print PIDs of Chrome processes that were launched with our user-data-dir.
  # This avoids nuking the user's normal Chrome.
  ps -eo pid=,args= | python3 -c '
import sys
profile = sys.argv[1]
for line in sys.stdin:
    line=line.rstrip("\n")
    if not line.strip():
        continue
    try:
        pid_str, args = line.strip().split(" ", 1)
    except ValueError:
        continue
    if ("--user-data-dir=%s" % profile) in args:
        print(pid_str)
' "$PROFILE_DIR"
}

chats_db_read() {
  if [[ -f "$CHATS_DB" ]]; then
    cat "$CHATS_DB" 2>/dev/null || true
  else
    printf '%s\n' '{"active":"","chats":{}}'
  fi
}

chats_db_write() {
  mkdir -p "$(dirname "$CHATS_DB")" >/dev/null 2>&1 || true
  cat >"$CHATS_DB"
}

chats_md_render() {
  chats_db_read | python3 -c '
import json,sys,datetime
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":"","chats":{}}
active=db.get("active") or ""
chats=db.get("chats") or {}

def fmt_ts(ts):
    try:
        return datetime.datetime.fromtimestamp(int(ts)).strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return "-"

print("# Specialist Sessions")
print("")
print("Active:", ("`%s`" % active) if active else "(none)")
print("")
print("| Active | Name | Last used | Loop | URL | Title |")
print("|---|---|---|---|---|---|")

for name in sorted(chats.keys()):
    c=chats.get(name) or {}
    mark="*" if name==active else ""
    url=c.get("url","")
    title=(c.get("title","") or "").replace("|"," ")
    ts=fmt_ts(c.get("last_used"))
    lm=c.get("loop_max")
    ld=c.get("loop_done")
    loop="-" if lm is None else f"{ld or 0}/{lm}"
    print(f"| {mark} | `{name}` | `{ts}` | `{loop}` | `{url}` | {title} |")
' >"$CHATS_MD" 2>/dev/null || true
}

chats_db_upsert() {
  # Usage: chats_db_upsert <name> <url> [title]
  local name="$1"
  local url="$2"
  local title="${3:-}"
  chats_db_read | python3 -c '
import json,sys,time
name, url, title = sys.argv[1], sys.argv[2], sys.argv[3]
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":"","chats":{}}
db.setdefault("chats", {})
db["chats"].setdefault(name, {})
db["chats"][name]["url"]=url
db["chats"][name]["last_used"]=int(time.time())
if title:
    db["chats"][name]["title"]=title
print(json.dumps(db, ensure_ascii=False, sort_keys=True))
' "$name" "$url" "$title" | chats_db_write
  chats_md_render
}

chats_db_set_active() {
  local name="$1"
  chats_db_read | python3 -c '
import json,sys
name=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":"","chats":{}}
db.setdefault("chats", {})
db["active"]=name
print(json.dumps(db, ensure_ascii=False, sort_keys=True))
' "$name" | chats_db_write
  chats_md_render
}

chats_db_delete() {
  local name="$1"
  chats_db_read | python3 -c '
import json,sys
name=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":"","chats":{}}
db.setdefault("chats", {})
db["chats"].pop(name, None)
if db.get("active")==name:
    db["active"]=""
print(json.dumps(db, ensure_ascii=False, sort_keys=True))
' "$name" | chats_db_write
  chats_md_render
}

chats_db_get_active_url() {
  chats_db_read | python3 -c '
import json,sys
try:
    db=json.load(sys.stdin)
except Exception:
    sys.exit(0)
active=db.get("active") or ""
chats=db.get("chats") or {}
if active and active in chats and "url" in chats[active]:
    print(chats[active]["url"])
'
}

chats_db_list() {
  chats_db_read | python3 -c '
import json,sys,datetime
import re
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":"","chats":{}}
active=db.get("active") or ""
chats=db.get("chats") or {}

def fmt_ts(ts):
    try:
        return datetime.datetime.fromtimestamp(int(ts)).strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return "-"

names=sorted(chats.keys())
if not names:
    print("No saved Specialist sessions.")
    sys.exit(0)

for idx, n in enumerate(names, start=1):
    c=chats[n] or {}
    mark="*" if n==active else " "
    url=c.get("url","")
    title=c.get("title","")
    ts=fmt_ts(c.get("last_used"))
    suffix=("  " + title) if title else ""
    if url and not re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]{16,}$", url):
        suffix = (suffix + " [INVALID_URL]").strip()
    # Human-friendly: index + name. User can say "continue 2" without pasting URLs.
    print("{} {}) {}  {}  {}{}".format(mark, idx, n, ts, url, suffix))
'
}

chats_db_find_name_by_url() {
  # Usage: chats_db_find_name_by_url <url>
  local url="$1"
  chats_db_read | python3 -c '
import json,sys
url=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    sys.exit(0)
chats=db.get("chats") or {}
for name,c in chats.items():
    if (c or {}).get("url")==url:
        print(name)
        break
' "$url"
}

chats_db_get_active_name() {
  chats_db_read | python3 -c '
import json,sys
try:
    db=json.load(sys.stdin)
except Exception:
    sys.exit(0)
active=(db.get("active") or "").strip()
if active:
    print(active)
'
}

chats_db_loop_init() {
  local max="$1"
  local active
  active="$(chats_db_get_active_name | head -n 1 || true)"
  if [[ -z "${active:-}" ]]; then
    echo "No active Specialist session. Use --use-chat NAME first." >&2
    exit 2
  fi
  chats_db_read | python3 -c '
import json,sys
active=sys.argv[1]
maxv=int(sys.argv[2])
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":active,"chats":{}}
db.setdefault("chats", {})
db["chats"].setdefault(active, {})
db["chats"][active]["loop_max"]=maxv
db["chats"][active]["loop_done"]=0
print(json.dumps(db, ensure_ascii=False, sort_keys=True))
' "$active" "$max" | chats_db_write
  chats_md_render
  echo "Loop set for $active: 0/$max" >&2
}

chats_db_loop_status() {
  local active
  active="$(chats_db_get_active_name | head -n 1 || true)"
  if [[ -z "${active:-}" ]]; then
    echo "No active Specialist session." >&2
    exit 2
  fi
  chats_db_read | python3 -c '
import json,sys
active=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    sys.exit(2)
c=(db.get("chats") or {}).get(active) or {}
lm=c.get("loop_max")
ld=c.get("loop_done") or 0
if lm is None:
    print("Loop: (not set)")
else:
    print(f"Loop: {ld}/{lm}")
' "$active"
}

chats_db_loop_inc() {
  local active
  active="$(chats_db_get_active_name | head -n 1 || true)"
  if [[ -z "${active:-}" ]]; then
    echo "No active Specialist session." >&2
    exit 2
  fi
  out="$(chats_db_read | python3 -c '
import json,sys
active=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":active,"chats":{}}
db.setdefault("chats", {})
db["chats"].setdefault(active, {})
c=db["chats"][active]
lm=c.get("loop_max")
ld=int(c.get("loop_done") or 0)
if lm is None:
    # no-op
    print(json.dumps(db, ensure_ascii=False, sort_keys=True))
    print("Loop: (not set)", file=sys.stderr)
    sys.exit(0)
lm=int(lm)
ld=min(ld+1, lm)
c["loop_done"]=ld
print(json.dumps(db, ensure_ascii=False, sort_keys=True))
print(f"Loop: {ld}/{lm}", file=sys.stderr)
' "$active")" || true
  # python printed JSON to stdout and status to stderr; here we only need JSON.
  printf '%s\n' "$out" | head -n 1 | chats_db_write
  chats_md_render
}

chats_db_loop_clear() {
  local active
  active="$(chats_db_get_active_name | head -n 1 || true)"
  if [[ -z "${active:-}" ]]; then
    echo "No active Specialist session." >&2
    exit 2
  fi
  chats_db_read | python3 -c '
import json,sys
active=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":active,"chats":{}}
chats=db.get("chats") or {}
c=chats.get(active) or {}
for k in ["loop_max","loop_done"]:
    if k in c:
        del c[k]
if active in chats:
    chats[active]=c
db["chats"]=chats
print(json.dumps(db, ensure_ascii=False, sort_keys=True))
' "$active" | chats_db_write
  chats_md_render
  echo "Loop cleared for $active" >&2
}

autoname() {
  # Timestamp-based, stable ASCII name for a new Specialist session.
  date +"auto-%Y%m%d-%H%M%S"
}

slugify_ascii() {
  # ASCII-only slug for filenames/session names. Russian text will be stripped.
  # Usage: slugify_ascii "Some text" -> "some-text"
  echo "${1:-}" \
    | tr '[:upper:]' '[:lower:]' \
    | sed -E 's/[^a-z0-9]+/-/g; s/^-+|-+$//g; s/-+/-/g' \
    | cut -c1-24
}

chats_db_has_name() {
  local name="$1"
  chats_db_read | python3 -c '
import json,sys
name=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    sys.exit(1)
chats=(db.get("chats") or {})
sys.exit(0 if name in chats else 1)
' "$name"
}

chats_db_unique_name() {
  # Usage: chats_db_unique_name <base>
  local base="$1"
  local n="$base"
  local i=2
  if [[ -z "${n//[[:space:]]/}" ]]; then
    n="$(autoname)"
  fi
  while chats_db_has_name "$n" >/dev/null 2>&1; do
    n="${base}-${i}"
    i=$((i+1))
  done
  printf '%s\n' "$n"
}

focus_chrome_window() {
  # Best-effort: raise the window for our automation profile so the user can see it.
  if ! command -v wmctrl >/dev/null 2>&1; then
    return 0
  fi
  # Some X11/WM states can make wmctrl emit BadWindow and return non-zero.
  # Never fail the whole command because of focus helpers.
  wmctrl -lx 2>/dev/null | python3 -c '
import sys
profile = sys.argv[1]
for line in sys.stdin:
    parts = line.strip().split(None, 3)
    if len(parts) < 3:
        continue
    wid = parts[0]
    wcls = parts[2]
    if profile in wcls:
        print(wid)
        break
' "$PROFILE_DIR" || true
}

cdp_open_tab() {
  # Best-effort: open a new tab in the shared Chrome instance.
  # Works only when CDP is up.
  local url="$1"
  if ! cdp_is_up; then
    return 1
  fi
  # Chrome 144+ requires PUT for /json/new; GET can return HTTP 405.
  local encoded endpoint hdr body http allow snippet
  encoded="$(python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=""))' "$url" 2>/dev/null || true)"
  [[ -z "${encoded:-}" ]] && encoded="$url"
  endpoint="http://127.0.0.1:${CDP_PORT}/json/new?${encoded}"
  hdr="$(mktemp)"
  body="$(mktemp)"

  http="$(curl -sS --max-time 2 -D "$hdr" -o "$body" -X PUT "$endpoint" -w '%{http_code}' || echo "000")"
  if [[ ! "$http" =~ ^2 ]]; then
    allow="$(awk 'tolower($1)=="allow:"{sub(/\r$/,"",$0); print $2}' "$hdr" | head -n 1 || true)"
    snippet="$(head -c 240 "$body" 2>/dev/null | tr '\n' ' ' | tr -d '\r')"
    echo "cdp_open_tab: PUT failed http=$http allow=${allow:-} body_snip=${snippet:-}" >&2

    http="$(curl -sS --max-time 2 -D "$hdr" -o "$body" -X GET "$endpoint" -w '%{http_code}' || echo "000")"
    if [[ ! "$http" =~ ^2 ]]; then
      allow="$(awk 'tolower($1)=="allow:"{sub(/\r$/,"",$0); print $2}' "$hdr" | head -n 1 || true)"
      snippet="$(head -c 240 "$body" 2>/dev/null | tr '\n' ' ' | tr -d '\r')"
      echo "[E_CDP_NEW_TAB_FAILED] cdp_open_tab: GET failed http=$http allow=${allow:-} body_snip=${snippet:-}" >&2
      export CHATGPT_SEND_ERROR_CODE="E_CDP_NEW_TAB_FAILED"
      rm -f "$hdr" "$body"
      return 1
    fi
  fi

  rm -f "$hdr" "$body"
  return 0
}

chat_id_from_url() {
  # Extract ChatGPT conversation id from a URL, if present.
  # Example: https://chatgpt.com/c/<id> -> <id>
  local u="${1:-}"
  if [[ "$u" =~ ^https://chatgpt\.com/c/([0-9a-fA-F-]{16,}).*$ ]]; then
    printf '%s\n' "${BASH_REMATCH[1]}"
    return 0
  fi
  return 1
}

capture_chat_title_for_url_from_cdp() {
  # Usage: capture_chat_title_for_url_from_cdp <url>
  # Prints the title (may be empty) for the matching chat URL.
  local target="$1"
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,sys
target=sys.argv[1]
try:
    tabs=json.load(sys.stdin)
except Exception:
    sys.exit(0)
for t in tabs:
    u=(t.get("url") or "").split("#",1)[0].strip()
    if u==target:
        print((t.get("title") or "").strip())
        break
' "$target"
}

cdp_cleanup_chat_tabs() {
  # Close extra ChatGPT conversation tabs so the user doesn't end up with a pile
  # of /c/... tabs. Keeps exactly one tab for the target chat id.
  local target_url="$1"
  local target_id
  target_id="$(chat_id_from_url "$target_url" 2>/dev/null || true)"
  if [[ -z "${target_id:-}" ]] || ! cdp_is_up; then
    return 0
  fi

  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys,urllib.parse
target_id=sys.argv[1]
raw=sys.stdin.read()
try:
    tabs=json.loads(raw)
except Exception:
    sys.exit(0)

def chat_id(u:str):
    m=re.match(r"^https://chatgpt\\.com/c/([0-9a-fA-F-]{16,})", u or "")
    return m.group(1) if m else None

keep=None
to_close=[]
for t in tabs:
    tid=(t.get("id") or "").strip()
    u=(t.get("url") or "").split("#",1)[0].strip()
    cid=chat_id(u)
    if not cid:
        continue
    if cid==target_id:
        if keep is None:
            keep=tid
        else:
            to_close.append(tid)
    else:
        to_close.append(tid)

for tid in to_close:
    if tid:
        print(tid)
' "$target_id" | while read -r tab_id; do
    [[ -z "${tab_id:-}" ]] && continue
    curl -fsS "http://127.0.0.1:${CDP_PORT}/json/close/${tab_id}" >/dev/null 2>&1 || true
  done
}

cdp_close_all_conversation_tabs() {
  # Close all ChatGPT conversation tabs (/c/...). Useful when starting a "new"
  # session to avoid sync ambiguity.
  if ! cdp_is_up; then
    return 0
  fi
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys
try:
    tabs=json.load(sys.stdin)
except Exception:
    sys.exit(0)
for t in tabs:
    tid=(t.get("id") or "").strip()
    u=(t.get("url") or "").split("#",1)[0].strip()
    if tid and re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]{16,}", u):
        print(tid)
' | while read -r tab_id; do
    [[ -z "${tab_id:-}" ]] && continue
    curl -fsS "http://127.0.0.1:${CDP_PORT}/json/close/${tab_id}" >/dev/null 2>&1 || true
  done
}

open_browser_impl() {
  # Usage: open_browser_impl <url>
  # Opens (or focuses) a shared automation Chrome instance and returns 0 on success.
  local url="$1"

  # Use a dedicated automation profile under this project (login persists).
  if [[ "$url" =~ ^https://chatgpt\.com/c/ ]] && ! is_chat_conversation_url "$url"; then
    echo "Warning: pinned chat URL is invalid; opening https://chatgpt.com/ instead." >&2
    url="https://chatgpt.com/"
  fi

  if cdp_is_up; then
    echo "Chrome already running (CDP port $CDP_PORT). Bringing its window to front..." >&2
    wid="$(focus_chrome_window | head -n 1 || true)"
    if [[ -n "${wid:-}" ]] && command -v wmctrl >/dev/null 2>&1; then
      wmctrl -ia "$wid" >/dev/null 2>&1 || true
    fi
    # By default we close existing conversation tabs when switching to home to
    # keep --sync-chatgpt-url unambiguous. Multi-child shared runs can disable
    # this via CHATGPT_SEND_PRESERVE_TABS=1 to avoid interfering with siblings.
    if [[ "$url" == "https://chatgpt.com/" ]] || [[ "$url" == "https://chatgpt.com" ]]; then
      if [[ "${PRESERVE_TABS}" != "1" ]]; then
        cdp_close_all_conversation_tabs || true
      fi
    fi
    # Activate existing tab if possible; only open a new one if missing.
    cdp_activate_or_open_url "$url" || true
    return 0
  fi

  if [[ $PRINT_URL -eq 1 ]]; then
    echo "ChatGPT URL: $url" >&2
  fi
  mkdir -p "$PROFILE_DIR" >/dev/null 2>&1 || true

  if [[ -n "${LOG_DIR:-}" ]]; then
    mkdir -p "${LOG_DIR}/cdp" >/dev/null 2>&1 || true
    chrome_log="${LOG_DIR}/cdp/chrome_${CDP_PORT}.log"
    chrome_pidfile="${LOG_DIR}/cdp/chrome_${CDP_PORT}.pid"
  else
    chrome_log="/tmp/chatgpt_send_chrome_${CDP_PORT}.log"
    chrome_pidfile="$ROOT/state/chrome_${CDP_PORT}.pid"
  fi
  rm -f "$chrome_log" >/dev/null 2>&1 || true

  # Use setsid to detach from the caller's process group/cgroup cleanup.
  setsid -f "$CHROME_PATH" \
    --remote-debugging-address=127.0.0.1 \
    --remote-debugging-port="$CDP_PORT" \
    --remote-allow-origins="http://127.0.0.1:${CDP_PORT}" \
    --no-first-run \
    --no-default-browser-check \
    --disable-gpu \
    --use-gl=swiftshader \
    --new-window \
    --user-data-dir="$PROFILE_DIR" \
    "$url" >"$chrome_log" 2>&1 || true
  : >"$chrome_pidfile" 2>/dev/null || true

  if wait_for_cdp; then
    echo "Opened Chrome (CDP port $CDP_PORT) at: $url" >&2
    wid="$(focus_chrome_window | head -n 1 || true)"
    if [[ -n "${wid:-}" ]] && command -v wmctrl >/dev/null 2>&1; then
      wmctrl -ia "$wid" >/dev/null 2>&1 || true
    fi
    return 0
  fi

  stale_pids="$(chrome_pids_for_profile | tr '\n' ' ' | sed 's/[[:space:]]*$//')"
  if [[ -n "${stale_pids//[[:space:]]/}" ]]; then
    echo "Chrome didn't come up (CDP $CDP_PORT). Found stale Chrome PIDs for this automation profile: $stale_pids" >&2
    echo "Trying to stop them and restart..." >&2
    for p in $stale_pids; do
      kill "$p" 2>/dev/null || true
    done
    sleep 0.8

    setsid -f "$CHROME_PATH" \
      --remote-debugging-address=127.0.0.1 \
      --remote-debugging-port="$CDP_PORT" \
      --remote-allow-origins="http://127.0.0.1:${CDP_PORT}" \
      --no-first-run \
      --no-default-browser-check \
      --disable-gpu \
      --use-gl=swiftshader \
      --new-window \
      --user-data-dir="$PROFILE_DIR" \
      "$url" >"$chrome_log" 2>&1 || true
    : >"$chrome_pidfile" 2>/dev/null || true

    if wait_for_cdp; then
      echo "Opened Chrome (CDP port $CDP_PORT) at: $url" >&2
      wid="$(focus_chrome_window | head -n 1 || true)"
      if [[ -n "${wid:-}" ]] && command -v wmctrl >/dev/null 2>&1; then
        wmctrl -ia "$wid" >/dev/null 2>&1 || true
      fi
      return 0
    fi
  fi

  echo "Failed to open a visible Chrome window. CDP is not reachable on 127.0.0.1:$CDP_PORT." >&2
  if [[ -f "$chrome_log" ]]; then
    echo "tail(chrome log):" >&2
    tail -n 120 "$chrome_log" >&2 || true
  fi
  return 1
}

capture_chat_url_from_cdp() {
  # Prints a single https://chatgpt.com/c/... URL or nothing if not found/ambiguous.
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys
raw = sys.stdin.read()
try:
    tabs = json.loads(raw)
except Exception:
    sys.exit(0)

urls = []
for t in tabs:
    u = (t.get("url") or "").strip()
    if re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]+", u):
        urls.append(u.split("#",1)[0])

uniq=[]
seen=set()
for u in urls:
    if u not in seen:
        uniq.append(u)
        seen.add(u)

if len(uniq) == 1:
    print(uniq[0])
'
}

capture_chat_urls_from_cdp() {
  # Prints all unique chat URLs (one per line).
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys
raw=sys.stdin.read()
try:
    tabs=json.loads(raw)
except Exception:
    sys.exit(0)
urls=[]
for t in tabs:
    u=(t.get("url") or "").strip()
    if re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]+", u):
        urls.append(u.split("#",1)[0])
seen=set()
for u in urls:
    if u not in seen:
        print(u)
        seen.add(u)
'
}

capture_chat_tab_from_cdp() {
  # Prints "url<TAB>title" when there is exactly one chat tab open.
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys
raw = sys.stdin.read()
try:
    tabs = json.loads(raw)
except Exception:
    sys.exit(0)

hits = []
for t in tabs:
    u = (t.get("url") or "").strip()
    if not u:
        continue
    if re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]+", u):
        hits.append((u.split("#",1)[0], (t.get("title") or "").strip()))

uniq=[]
seen=set()
for u,title in hits:
    if u not in seen:
        uniq.append((u,title))
        seen.add(u)

if len(uniq) == 1:
    u,title = uniq[0]
    print(u + "\t" + title)
'
}

capture_chat_tab_from_cdp_last() {
  # Prints "url<TAB>title" for the last chat tab in the CDP list (best-effort).
  # This is a fallback for humans: when multiple chat tabs are open, we still
  # want to sync *something* (usually the most recently created tab).
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys
raw = sys.stdin.read()
try:
    tabs = json.loads(raw)
except Exception:
    sys.exit(0)

hits = []
for t in tabs:
    u = (t.get("url") or "").strip()
    if not u:
        continue
    if re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]+", u):
        hits.append((u.split("#",1)[0], (t.get("title") or "").strip()))

uniq=[]
seen=set()
for u,title in hits:
    if u not in seen:
        uniq.append((u,title))
        seen.add(u)

if uniq:
    u,title = uniq[-1]
    print(u + "\t" + title)
'
}

capture_best_chat_tab_from_cdp() {
  # Prints "url<TAB>title" selecting the most likely "new" chat.
  # Heuristic: if multiple chat tabs exist, pick the first URL that is not yet
  # present in our chats DB; otherwise pick the last chat URL.
  curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys,os
chats_db_path=sys.argv[1]
try:
    tabs=json.load(sys.stdin)
except Exception:
    sys.exit(0)

known=set()
try:
    with open(chats_db_path,"r",encoding="utf-8") as f:
        db=json.load(f)
    for c in (db.get("chats") or {}).values():
        u=(c or {}).get("url") or ""
        if isinstance(u,str) and u.startswith("https://chatgpt.com/c/"):
            known.add(u)
except Exception:
    pass

hits=[]
for t in tabs:
    u=(t.get("url") or "").strip()
    if not u:
        continue
    if re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]+", u):
        hits.append((u.split("#",1)[0], (t.get("title") or "").strip()))

uniq=[]
seen=set()
for u,title in hits:
    if u not in seen:
        uniq.append((u,title))
        seen.add(u)

if not uniq:
    sys.exit(0)

# Prefer an unknown URL (likely newly created chat).
for u,title in uniq:
    if u not in known:
        print(u + "\t" + title)
        sys.exit(0)

# Otherwise pick the last one.
u,title=uniq[-1]
print(u + "\t" + title)
' "$CHATS_DB"
}

cdp_activate_or_open_url() {
  # Usage: cdp_activate_or_open_url <url>
  local target="$1"
  if ! cdp_is_up; then
    return 1
  fi
  # Try to find an existing tab and activate it; otherwise open a new one.
  local tab_id
  tab_id="$(curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys
target=sys.argv[1]
target=target.split("#",1)[0].strip()
target_id=None
m=re.match(r"^https://chatgpt\\.com/c/([0-9a-fA-F-]{16,})", target)
if m:
    target_id=m.group(1)
try:
    tabs=json.load(sys.stdin)
except Exception:
    sys.exit(0)

def chat_id(u:str):
    m=re.match(r"^https://chatgpt\\.com/c/([0-9a-fA-F-]{16,})", u or "")
    return m.group(1) if m else None

for t in tabs:
    u=(t.get("url") or "").split("#",1)[0].strip()
    tid=(t.get("id") or "").strip()
    if not tid:
        continue
    if target_id:
        if chat_id(u)==target_id:
            print(tid)
            break
    else:
        if u==target:
            print(tid)
            break
' "$target" | head -n 1 || true)"

  if [[ -n "${tab_id:-}" ]]; then
    curl -fsS "http://127.0.0.1:${CDP_PORT}/json/activate/${tab_id}" >/dev/null 2>&1 || true
  else
    cdp_open_tab "$target" || true
  fi
  # Raise the window so user can see the chat.
  local wid
  wid="$(focus_chrome_window | head -n 1 || true)"
  if [[ -n "${wid:-}" ]] && command -v wmctrl >/dev/null 2>&1; then
    wmctrl -ia "$wid" >/dev/null 2>&1 || true
  fi
  return 0
}

if [[ -n "${LOCK_FILE:-}" ]] && [[ "${LOCK_HELD}" != "1" ]]; then
  mkdir -p "$(dirname "$LOCK_FILE")" >/dev/null 2>&1 || true
  if command -v flock >/dev/null 2>&1; then
    lock_run_id="${CHATGPT_SEND_LOCK_RUN_ID:-lock-$(date +%s)-$$}"
    _now_ms() { date +%s%3N 2>/dev/null || python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
}
    lock_wait_start_ms="$(_now_ms)"
    exec {lock_fd}>"$LOCK_FILE"
    set +e
    flock -x -w "$LOCK_TIMEOUT_SEC" -E 75 "$lock_fd"
    lock_acq_st=$?
    set -e
    lock_acq_ms="$(_now_ms)"
    lock_wait_ms=$((lock_acq_ms - lock_wait_start_ms))
    echo "[LOCK] event=acquire_attempt run_id=${lock_run_id} lock_file=${LOCK_FILE} wait_ms=${lock_wait_ms}" >&2
    if [[ $lock_acq_st -ne 0 ]]; then
      exec {lock_fd}>&- || true
      if [[ $lock_acq_st -eq 75 ]]; then
        echo "[E_LOCK_TIMEOUT] Failed to acquire chatgpt_send lock within ${LOCK_TIMEOUT_SEC}s: $LOCK_FILE" >&2
        export CHATGPT_SEND_ERROR_CODE="E_LOCK_TIMEOUT"
        exit 70
      fi
      exit $lock_acq_st
    fi
    export CHATGPT_SEND_LOCK_HELD=1
    export CHATGPT_SEND_LOCK_RUN_ID="$lock_run_id"
    set +e
    "$SCRIPT_PATH" "${ORIG_ARGS[@]}"
    lock_st=$?
    set -e
    lock_rel_ms="$(_now_ms)"
    lock_held_ms=$((lock_rel_ms - lock_acq_ms))
    echo "[LOCK] event=release run_id=${lock_run_id} lock_file=${LOCK_FILE} lock_held_ms=${lock_held_ms}" >&2
    flock -u "$lock_fd" >/dev/null 2>&1 || true
    exec {lock_fd}>&- || true
    if [[ $lock_st -ne 0 ]]; then
      exit $lock_st
    fi
    exit $lock_st
  else
    echo "Warning: CHATGPT_SEND_LOCK_FILE is set but flock is unavailable; running without lock." >&2
  fi
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --prompt) PROMPT="$2"; shift 2;;
    --prompt-file) PROMPT_FILE="$2"; shift 2;;
    --model) MODEL="$2"; shift 2;;
    --model-strategy) MODEL_STRATEGY="$2"; shift 2;;
    --keep-browser) KEEP_BROWSER=1; shift;;
    --no-keep-browser) KEEP_BROWSER=0; shift;;
    --manual-login) MANUAL_LOGIN=1; shift;;
    --no-manual-login) MANUAL_LOGIN=0; shift;;
    --chrome-path) CHROME_PATH="$2"; shift 2;;
    --chatgpt-url) CHATGPT_URL="$2"; CHATGPT_URL_EXPLICIT=1; shift 2;;
    --chat-id) CHATGPT_URL="https://chatgpt.com/c/$2"; CHATGPT_URL_EXPLICIT=1; shift 2;;
    --init-specialist) INIT_SPECIALIST=1; shift;;
    --topic) INIT_TOPIC="$2"; shift 2;;
    --set-active-title) SET_ACTIVE_TITLE="$2"; shift 2;;
    --open-browser) OPEN_BROWSER=1; shift;;
    --sync-chatgpt-url) SYNC_URL=1; shift;;
    --print-chatgpt-url) PRINT_URL=1; shift;;
    --cdp-port) CDP_PORT="$2"; shift 2;;
    --list-chats) LIST_CHATS=1; shift;;
    --doctor) DOCTOR=1; shift;;
    --save-chat) SAVE_CHAT_NAME="$2"; shift 2;;
    --use-chat) USE_CHAT_NAME="$2"; shift 2;;
    --delete-chat) DELETE_CHAT_NAME="$2"; shift 2;;
    --loop-init) LOOP_INIT="$2"; shift 2;;
    --loop-status) LOOP_STATUS=1; shift;;
    --loop-inc) LOOP_INC=1; shift;;
    --loop-clear) LOOP_CLEAR=1; shift;;
    --set-chatgpt-url)
      mkdir -p "$(dirname "$CHATGPT_URL_FILE")" >/dev/null 2>&1 || true
      url="$2"
      # If the user tries to set a /c/... URL, enforce validity (prevents saving garbage like /c/test-loop).
      if [[ "$url" =~ ^https://chatgpt\.com/c/ ]] && ! is_chat_conversation_url "$url"; then
        echo "Error: invalid ChatGPT conversation URL: $url" >&2
        exit 2
      fi

      printf '%s\n' "$url" >"$CHATGPT_URL_FILE"

      # Persist as a Specialist session only when it's a conversation URL.
      if is_chat_conversation_url "$url"; then
        chats_db_upsert "last" "$url" "" >/dev/null 2>&1 || true
        chats_db_set_active "last" >/dev/null 2>&1 || true
      fi

      echo "Saved default ChatGPT URL: $url" >&2
      exit 0
      ;;
    --clear-chatgpt-url)
      rm -f "$CHATGPT_URL_FILE"
      echo "Cleared default ChatGPT URL." >&2
      exit 0
      ;;
    --show-chatgpt-url)
      if [[ -f "$CHATGPT_URL_FILE" ]]; then
        cat "$CHATGPT_URL_FILE"
        exit 0
      fi
      if [[ -n "${CHATGPT_URL_DEFAULT:-}" ]]; then
        echo "$CHATGPT_URL_DEFAULT"
        exit 0
      fi
      if cdp_is_up; then
        tab="$(capture_best_chat_tab_from_cdp || true)"
        detected="${tab%%$'\t'*}"
        if [[ -n "${detected:-}" ]] && [[ "$detected" != "$tab" ]] && is_chat_conversation_url "$detected"; then
          echo "$detected"
          exit 0
        fi
      fi
      echo ""  # empty means "no default"
      exit 0
      ;;
    --timeout) TIMEOUT="$2"; shift 2;;
    --attach) ATTACH+=("$2"); shift 2;;
    --dry-run) DRY_RUN=1; shift;;
    -h|--help) usage; exit 0;;
    *) echo "Unknown arg: $1" >&2; usage >&2; exit 2;;
  esac
done

# Chat database operations (human-friendly "Specialist sessions")
if [[ $LIST_CHATS -eq 1 ]]; then
  chats_db_list
  exit 0
fi

if [[ $DOCTOR -eq 1 ]]; then
  echo "chatgpt_send doctor"
  echo "  root: $ROOT"
  echo "  cdp_port: $CDP_PORT"
  if cdp_is_up; then
    echo "  cdp: OK"
  else
    echo "  cdp: DOWN"
  fi

  pinned=""
  if [[ -f "$CHATGPT_URL_FILE" ]]; then
    pinned="$(cat "$CHATGPT_URL_FILE" | head -n 1 || true)"
  fi
  echo "  pinned_url: ${pinned:-"(none)"}"

  active="$(chats_db_get_active_name | head -n 1 || true)"
  echo "  active_session: ${active:-"(none)"}"

  if [[ -n "${active:-}" ]]; then
    (chats_db_loop_status 2>/dev/null | sed 's/^/  /') || true
  fi

  if cdp_is_up; then
    echo "  open_chat_tabs:"
    curl -fsS "http://127.0.0.1:${CDP_PORT}/json/list" | python3 -c '
import json,re,sys
try:
    tabs=json.load(sys.stdin)
except Exception:
    sys.exit(0)
hits=[]
for t in tabs:
    u=(t.get("url") or "").split("#",1)[0].strip()
    if re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]{16,}", u):
        hits.append((t.get("id") or "", u, (t.get("title") or "").strip()))
for tid,u,title in hits[:12]:
    print("   -", tid, u, ("(" + title + ")") if title else "")
print("   total:", len(hits))
'
  fi
  exit 0
fi

if [[ -n "${SET_ACTIVE_TITLE//[[:space:]]/}" ]]; then
  active="$(chats_db_get_active_name | head -n 1 || true)"
  if [[ -z "${active:-}" ]]; then
    echo "No active Specialist session." >&2
    exit 2
  fi
  # Update title of active session.
  chats_db_read | python3 -c '
import json,sys
active=sys.argv[1]
title=sys.argv[2]
try:
    db=json.load(sys.stdin)
except Exception:
    db={"active":active,"chats":{}}
db.setdefault("chats", {})
db["chats"].setdefault(active, {})
db["chats"][active]["title"]=title
print(json.dumps(db, ensure_ascii=False, sort_keys=True))
' "$active" "$SET_ACTIVE_TITLE" | chats_db_write
  chats_md_render
  echo "Updated title for $active" >&2
  exit 0
fi

if [[ $INIT_SPECIALIST -eq 1 ]]; then
  if [[ "${WAIT_ONLY}" == "1" ]]; then
    emit_wait_only_block "init_specialist"
  fi
  # Ensure a shared browser exists and force a "new chat" page. Then send the
  # bootstrap prompt which will create a /c/<id> URL that we can pin.
  open_browser_impl "https://chatgpt.com/" || exit 1
  CHATGPT_URL="https://chatgpt.com/"
  topic="${INIT_TOPIC:-}"
  # Allow passing topic via --prompt/--prompt-file too.
  if [[ -z "${topic//[[:space:]]/}" ]] && [[ -n "${PROMPT//[[:space:]]/}" ]]; then
    topic="$PROMPT"
  fi
  if [[ -z "${topic//[[:space:]]/}" ]] && [[ -n "${PROMPT_FILE:-}" ]]; then
    topic="$(cat "$PROMPT_FILE" 2>/dev/null || true)"
  fi

  bootstrap="$(cat "$ROOT/docs/specialist_bootstrap.txt" 2>/dev/null || true)"
  PROMPT="$bootstrap"
  if [[ -n "${topic//[[:space:]]/}" ]]; then
    PROMPT+=$'\n\n'"Коротко: ${topic}"
  fi
  PROMPT_FILE=""

  # Prepare a nicer session name/title for the newly created chat.
  if [[ -n "${topic//[[:space:]]/}" ]]; then
    INIT_SESSION_TITLE="${topic} ($(date +%Y-%m-%d))"
    base_slug="$(slugify_ascii "$topic")"
    if [[ -z "${base_slug//[[:space:]]/}" ]]; then
      base_slug="session"
    fi
    INIT_SESSION_NAME="${base_slug}-$(date +%Y%m%d-%H%M%S)"
    INIT_SESSION_NAME="$(chats_db_unique_name "$INIT_SESSION_NAME")"
  else
    INIT_SESSION_TITLE="Specialist session ($(date +%Y-%m-%d))"
    INIT_SESSION_NAME="$(chats_db_unique_name "session-$(date +%Y%m%d-%H%M%S)")"
  fi
fi

if [[ -n "${LOOP_INIT//[[:space:]]/}" ]]; then
  chats_db_loop_init "$LOOP_INIT"
  exit 0
fi

if [[ $LOOP_STATUS -eq 1 ]]; then
  chats_db_loop_status
  exit 0
fi

if [[ $LOOP_INC -eq 1 ]]; then
  chats_db_loop_inc
  exit 0
fi

if [[ $LOOP_CLEAR -eq 1 ]]; then
  chats_db_loop_clear
  exit 0
fi

if [[ -n "${DELETE_CHAT_NAME//[[:space:]]/}" ]]; then
  chats_db_delete "$DELETE_CHAT_NAME"
  exit 0
fi

if [[ -n "${USE_CHAT_NAME//[[:space:]]/}" ]]; then
  resolved="$(chats_db_read | python3 -c '
import json,sys,re
name=sys.argv[1]
try:
    db=json.load(sys.stdin)
except Exception:
    sys.exit(0)
chats=(db.get("chats") or {})
names=sorted(chats.keys())
if name.isdigit():
    idx=int(name)
    if 1 <= idx <= len(names):
        name=names[idx-1]
c=(chats.get(name) or {})
u=c.get("url","")
if u and re.match(r"^https://chatgpt\.com/c/[0-9a-fA-F-]{16,}$", u):
    print(name + "\t" + u)
' "$USE_CHAT_NAME")"
  resolved_name="${resolved%%$'\t'*}"
  url="${resolved#*$'\t'}"
  if [[ -z "${url:-}" ]]; then
    echo "Unknown chat name: $USE_CHAT_NAME" >&2
    exit 2
  fi
  chats_db_set_active "$resolved_name" >/dev/null 2>&1 || true
  mkdir -p "$(dirname "$CHATGPT_URL_FILE")" >/dev/null 2>&1 || true
  printf '%s\n' "$url" >"$CHATGPT_URL_FILE"
  echo "Using chat: $resolved_name" >&2
  exit 0
fi

# Resolve default chat URL (persisted or env) if caller didn't specify one.
if [[ -z "$CHATGPT_URL" ]]; then
  if [[ -f "$CHATGPT_URL_FILE" ]]; then
    CHATGPT_URL="$(cat "$CHATGPT_URL_FILE" | head -n 1)"
  elif [[ -n "${CHATGPT_URL_DEFAULT:-}" ]]; then
    CHATGPT_URL="$CHATGPT_URL_DEFAULT"
  else
    CHATGPT_URL="$(chats_db_get_active_url || true)"
  fi
fi

# Optional hard route pin for child/coordinator flows.
# When set, all sends are forced to this exact /c/... URL.
if [[ -n "${CHATGPT_SEND_FORCE_CHAT_URL:-}" ]]; then
  if is_chat_conversation_url "${CHATGPT_SEND_FORCE_CHAT_URL}"; then
    CHATGPT_URL="${CHATGPT_SEND_FORCE_CHAT_URL}"
    CHATGPT_URL_EXPLICIT=1
    if [[ $PRINT_URL -eq 1 ]]; then
      echo "[P3] forced_chat_url=${CHATGPT_URL}" >&2
    fi
  else
    echo "Warning: ignoring invalid CHATGPT_SEND_FORCE_CHAT_URL: ${CHATGPT_SEND_FORCE_CHAT_URL}" >&2
  fi
fi

# If caller passed generic home URL, prefer continuing active Specialist chat.
# This preserves context by default and prevents accidental "new chat" sends.
# Set CHATGPT_SEND_HOME_REUSES_ACTIVE=0 to disable.
if [[ $INIT_SPECIALIST -eq 0 ]] && [[ "${CHATGPT_SEND_HOME_REUSES_ACTIVE:-1}" != "0" ]] && [[ $CHATGPT_URL_EXPLICIT -eq 0 ]]; then
  if [[ "${CHATGPT_URL:-}" == "https://chatgpt.com/" || "${CHATGPT_URL:-}" == "https://chatgpt.com" ]]; then
    active_url="$(chats_db_get_active_url || true)"
    if [[ -n "${active_url:-}" ]] && is_chat_conversation_url "$active_url"; then
      CHATGPT_URL="$active_url"
      if [[ $PRINT_URL -eq 1 ]]; then
        echo "Reusing active Specialist chat: $CHATGPT_URL" >&2
      fi
    fi
  fi
elif [[ $INIT_SPECIALIST -eq 0 ]] && [[ "${CHATGPT_SEND_HOME_REUSES_ACTIVE:-1}" != "0" ]] && [[ $CHATGPT_URL_EXPLICIT -eq 1 ]]; then
  if [[ $PRINT_URL -eq 1 ]]; then
    echo "Not reusing active chat: explicit --chatgpt-url set." >&2
  fi
fi

if [[ $OPEN_BROWSER -eq 1 ]]; then
  if [[ "${WAIT_ONLY}" == "1" ]]; then
    emit_wait_only_block "open_browser"
  fi
  url="${CHATGPT_URL:-https://chatgpt.com/}"
  open_browser_impl "$url" || exit 1
  exit 0
fi

if [[ $SYNC_URL -eq 1 ]]; then
  if [[ "${WAIT_ONLY}" == "1" ]]; then
    emit_wait_only_block "sync_chat_url"
  fi
  if ! cdp_is_up; then
    echo "CDP is not reachable on 127.0.0.1:$CDP_PORT. Run open-browser first." >&2
    exit 2
  fi
  tab="$(capture_best_chat_tab_from_cdp || true)"
  detected="${tab%%$'\t'*}"
  title="${tab#*$'\t'}"
  if [[ -z "${detected:-}" ]] || [[ "$detected" == "$tab" ]]; then
    echo "Could not detect any https://chatgpt.com/c/... tab." >&2
    exit 3
  fi
  mkdir -p "$(dirname "$CHATGPT_URL_FILE")" >/dev/null 2>&1 || true
  printf '%s\n' "$detected" >"$CHATGPT_URL_FILE"
  chats_db_upsert "last" "$detected" "${title:-}" >/dev/null 2>&1 || true
  existing="$(chats_db_find_name_by_url "$detected" | head -n 1 || true)"
  if [[ -z "${existing:-}" ]] || [[ "$existing" == "last" ]]; then
    name="$(autoname)"
    chats_db_upsert "$name" "$detected" "${title:-}" >/dev/null 2>&1 || true
    chats_db_set_active "$name" >/dev/null 2>&1 || true
  else
    chats_db_set_active "$existing" >/dev/null 2>&1 || true
  fi
  echo "Synced default ChatGPT URL: $detected" >&2
  exit 0
fi

# If a pinned URL exists but it's an invalid conversation URL, ignore it for sending.
if [[ -n "${CHATGPT_URL:-}" ]] && [[ "$CHATGPT_URL" =~ ^https://chatgpt\.com/c/ ]] && ! is_chat_conversation_url "$CHATGPT_URL"; then
  echo "Warning: ignoring invalid pinned chat URL: $CHATGPT_URL" >&2
  CHATGPT_URL=""
fi

if [[ -n "${SAVE_CHAT_NAME//[[:space:]]/}" ]]; then
  if [[ -z "${CHATGPT_URL:-}" ]] && cdp_is_up; then
    tab="$(capture_chat_tab_from_cdp || true)"
    CHATGPT_URL="${tab%%$'\t'*}"
    title="${tab#*$'\t'}"
  fi
  if [[ -z "${CHATGPT_URL:-}" ]]; then
    echo "No chat URL to save. Provide --chatgpt-url, pin one via --set-chatgpt-url, or open browser and keep a single chat tab open." >&2
    exit 2
  fi
  chats_db_upsert "$SAVE_CHAT_NAME" "$CHATGPT_URL" "${title:-}" >/dev/null 2>&1 || true
  chats_db_set_active "$SAVE_CHAT_NAME" >/dev/null 2>&1 || true
  printf '%s\n' "$CHATGPT_URL" >"$CHATGPT_URL_FILE" 2>/dev/null || true
  echo "Saved chat as: $SAVE_CHAT_NAME" >&2
  exit 0
fi

EXPLICIT_HOME_PROBE=0
if [[ $CHATGPT_URL_EXPLICIT -eq 1 ]] && [[ "${CHATGPT_URL:-}" == "https://chatgpt.com/" || "${CHATGPT_URL:-}" == "https://chatgpt.com" ]]; then
  EXPLICIT_HOME_PROBE=1
fi
OLD_ACTIVE_NAME="$(chats_db_get_active_name | head -n 1 || true)"
OLD_ACTIVE_URL="$(chats_db_get_active_url | head -n 1 || true)"
if [[ $PRINT_URL -eq 1 ]]; then
  echo "[P2] explicit_home_probe=${EXPLICIT_HOME_PROBE} active_before=${OLD_ACTIVE_NAME:-"(none)"} active_url_before=${OLD_ACTIVE_URL:-"(none)"}" >&2
fi

if [[ -n "$PROMPT_FILE" ]]; then
  if [[ "${WAIT_ONLY}" == "1" ]]; then
    emit_wait_only_block "prompt_file_send"
  fi
  PROMPT="$(cat "$PROMPT_FILE")"
fi

if [[ "${WAIT_ONLY}" == "1" ]] && [[ -n "${PROMPT//[[:space:]]/}" ]]; then
  emit_wait_only_block "prompt_send"
fi

if [[ -z "${PROMPT//[[:space:]]/}" ]]; then
  if [[ "${WAIT_ONLY}" == "1" ]]; then
    emit_wait_only_block "stdin_send"
  fi
  if [[ -t 0 ]]; then
    echo "Missing prompt. Provide --prompt/--prompt-file or pipe via stdin." >&2
    exit 2
  fi
  PROMPT="$(cat)"
fi

if [[ -z "${PROMPT//[[:space:]]/}" ]]; then
  echo "Prompt is empty" >&2
  exit 2
fi

# If no explicit/default chat URL is configured, try to auto-capture it from the
# already-open shared Chrome instance. This enables the UX:
# "open browser" -> user creates chat -> first send auto-pins that chat.
if [[ -z "$CHATGPT_URL" ]] && cdp_is_up; then
  tab="$(capture_chat_tab_from_cdp || true)"
  detected="${tab%%$'\t'*}"
  title="${tab#*$'\t'}"
  if [[ -n "${detected:-}" ]] && [[ "$detected" != "$tab" ]]; then
    CHATGPT_URL="$detected"
    mkdir -p "$(dirname "$CHATGPT_URL_FILE")" >/dev/null 2>&1 || true
    printf '%s\n' "$CHATGPT_URL" >"$CHATGPT_URL_FILE"
    chats_db_upsert "last" "$CHATGPT_URL" "${title:-}" >/dev/null 2>&1 || true
    existing="$(chats_db_find_name_by_url "$CHATGPT_URL" | head -n 1 || true)"
    if [[ "${EXPLICIT_HOME_PROBE}" == "1" ]]; then
      echo "[P2] active_update=skipped reason=explicit_home_probe old_active=${OLD_ACTIVE_URL:-"(none)"} new_candidate=${CHATGPT_URL}" >&2
    else
      if [[ -z "${existing:-}" ]] || [[ "$existing" == "last" ]]; then
        name="$(autoname)"
        chats_db_upsert "$name" "$CHATGPT_URL" "${title:-}" >/dev/null 2>&1 || true
        chats_db_set_active "$name" >/dev/null 2>&1 || true
      else
        chats_db_set_active "$existing" >/dev/null 2>&1 || true
      fi
    fi
  fi
fi

# Hard send guard: prevent "wrong chat" drift by requiring a conversation URL
# and consistent active/pinned metadata before every normal prompt send.
if [[ $INIT_SPECIALIST -eq 0 ]]; then
  pinned_url_current=""
  if [[ -f "$CHATGPT_URL_FILE" ]]; then
    pinned_url_current="$(cat "$CHATGPT_URL_FILE" | head -n 1 || true)"
  fi
  active_url_current="$(chats_db_get_active_url | head -n 1 || true)"

  if [[ "${ENFORCE_ACTIVE_PIN_MATCH}" == "1" ]] \
    && is_chat_conversation_url "${active_url_current:-}" \
    && is_chat_conversation_url "${pinned_url_current:-}" \
    && [[ "${active_url_current}" != "${pinned_url_current}" ]]; then
    emit_chat_state_mismatch "${active_url_current}" "${pinned_url_current}"
  fi

  if [[ "${REQUIRE_CONVO_URL}" == "1" ]]; then
    if is_chat_conversation_url "${CHATGPT_URL:-}"; then
      :
    elif [[ "${ALLOW_HOME_SEND}" == "1" ]] \
      && [[ "${CHATGPT_URL:-}" == "https://chatgpt.com/" || "${CHATGPT_URL:-}" == "https://chatgpt.com" ]]; then
      log_action "target_guard" "result=allow_home_send"
    else
      emit_target_chat_required "${CHATGPT_URL:-none}"
    fi
  fi
fi

has_convo_url=0
if [[ -n "${CHATGPT_URL:-}" ]] && is_chat_conversation_url "$CHATGPT_URL"; then
  has_convo_url=1
fi

slug="send-$(date +%Y%m%d-%H%M%S)"
if [[ -n "${LOG_DIR:-}" ]]; then
  mkdir -p "${LOG_DIR}/cdp" >/dev/null 2>&1 || true
  out="${LOG_DIR}/cdp/chatgpt_send_${slug}_$$.md"
else
  out="/tmp/chatgpt_send_${slug}_$$.md"
fi

# Ensure we have a visible, shared Chrome to operate against.
# (Do this before we capture pre/post URLs for auto-pinning.)
if ! cdp_is_up; then
  open_browser_impl "${CHATGPT_URL:-https://chatgpt.com/}" || exit 1
fi
if ! cdp_is_up; then
  echo "CDP is not reachable on 127.0.0.1:$CDP_PORT. Browser is not ready." >&2
  exit 2
fi

# If no conversation URL is pinned yet, remember current chat tabs; after the
# first send we can pin the newly created conversation URL.
pre_chat_urls=""
if [[ $has_convo_url -eq 0 ]] && cdp_is_up; then
  pre_chat_urls="$(capture_chat_urls_from_cdp | sort -u || true)"
fi

# If we already have a pinned conversation URL and CDP is available, activate it
# before sending so the human can see the message being sent in the same tab.
if [[ $has_convo_url -eq 1 ]] && cdp_is_up; then
  cdp_activate_or_open_url "$CHATGPT_URL" || true
  cdp_cleanup_chat_tabs "$CHATGPT_URL" || true
fi

if [[ $DRY_RUN -eq 1 ]]; then
  echo "(dry-run) would send prompt to: ${CHATGPT_URL:-https://chatgpt.com/}" >&2
  echo "(dry-run) prompt bytes: $(printf '%s' "$PROMPT" | wc -c | tr -d ' ')" >&2
  exit 0
fi

if [[ $PRINT_URL -eq 1 ]]; then
  echo "ChatGPT URL: ${CHATGPT_URL:-https://chatgpt.com/}" >&2
fi

timeout_s="$(resolve_timeout_seconds)"
PRECHECK_DONE=0

precheck_via_cdp() {
  python3 "$ROOT/bin/cdp_chatgpt.py" \
    --cdp-port "$CDP_PORT" \
    --chatgpt-url "${CHATGPT_URL:-https://chatgpt.com/}" \
    --timeout "$timeout_s" \
    --prompt "$PROMPT" \
    --precheck-only >"$out"
}

precheck_auto_wait_loop() {
  local max_sec poll_ms poll_s start_ms now elapsed_ms max_ms precheck_status
  max_sec="$AUTO_WAIT_MAX_SEC"
  poll_ms="$AUTO_WAIT_POLL_MS"
  [[ "$max_sec" =~ ^[0-9]+$ ]] || max_sec=60
  [[ "$poll_ms" =~ ^[0-9]+$ ]] || poll_ms=500
  (( max_sec < 1 )) && max_sec=1
  (( poll_ms < 50 )) && poll_ms=50
  poll_s="$(awk -v ms="$poll_ms" 'BEGIN { printf "%.3f", ms/1000 }')"
  start_ms="$(now_ms)"
  max_ms=$((max_sec * 1000))

  echo "AUTO_WAIT start max_sec=${max_sec} poll_ms=${poll_ms} run_id=${RUN_ID}" >&2
  while true; do
    sleep "$poll_s"
    now="$(now_ms)"
    elapsed_ms=$((now - start_ms))
    echo "AUTO_WAIT tick elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
    if (( elapsed_ms >= max_ms )); then
      echo "AUTO_WAIT done outcome=timeout elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
      echo "E_AUTO_WAIT_TIMEOUT elapsed_ms=${elapsed_ms} max_sec=${max_sec} run_id=${RUN_ID}" >&2
      return 73
    fi

    precheck_via_cdp
    precheck_status=$?

    if [[ $precheck_status -eq 11 ]]; then
      continue
    fi
    if [[ $precheck_status -eq 0 ]]; then
      echo "AUTO_WAIT done outcome=reuse elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
      return 0
    fi
    if [[ $precheck_status -eq 10 ]]; then
      echo "AUTO_WAIT done outcome=send elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
      return 10
    fi
    echo "AUTO_WAIT done outcome=precheck_status${precheck_status} elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
    return "$precheck_status"
  done
}

run_send_checked() {
  local stage="${1:-send}"
  if [[ "${PRECHECK_DONE}" != "1" ]]; then
    echo "E_SEND_WITHOUT_PRECHECK stage=${stage} run_id=${RUN_ID}" >&2
    return 71
  fi
  log_action "send" "stage=${stage}"
  if [[ "${REPLY_POLLING}" == "1" ]]; then
    send_no_wait_via_cdp
  else
    send_via_cdp
  fi
}

# Use CDP to type/click in the existing, visible ChatGPT tab and then scrape
# the final assistant response.
send_via_cdp() {
  python3 "$ROOT/bin/cdp_chatgpt.py" \
    --cdp-port "$CDP_PORT" \
    --chatgpt-url "${CHATGPT_URL:-https://chatgpt.com/}" \
    --timeout "$timeout_s" \
    --prompt "$PROMPT" >"$out"
}

send_no_wait_via_cdp() {
  python3 "$ROOT/bin/cdp_chatgpt.py" \
    --cdp-port "$CDP_PORT" \
    --chatgpt-url "${CHATGPT_URL:-https://chatgpt.com/}" \
    --timeout "$timeout_s" \
    --prompt "$PROMPT" \
    --send-no-wait >"$out"
}

reply_ready_probe_via_cdp() {
  python3 "$ROOT/bin/cdp_chatgpt.py" \
    --cdp-port "$CDP_PORT" \
    --chatgpt-url "${CHATGPT_URL:-https://chatgpt.com/}" \
    --timeout "20" \
    --prompt "$PROMPT" \
    --reply-ready-probe >/dev/null
}

reply_wait_collect_via_probe() {
  local max_sec poll_ms poll_s start_ms now elapsed_ms max_ms probe_status fetch_status
  max_sec="$REPLY_MAX_SEC"
  poll_ms="$REPLY_POLL_MS"
  [[ "$max_sec" =~ ^[0-9]+$ ]] || max_sec=90
  [[ "$poll_ms" =~ ^[0-9]+$ ]] || poll_ms=700
  (( max_sec < 1 )) && max_sec=1
  (( poll_ms < 100 )) && poll_ms=100
  poll_s="$(awk -v ms="$poll_ms" 'BEGIN { printf "%.3f", ms/1000 }')"
  start_ms="$(now_ms)"
  max_ms=$((max_sec * 1000))

  echo "REPLY_WAIT start max_sec=${max_sec} poll_ms=${poll_ms} run_id=${RUN_ID}" >&2
  while true; do
    now="$(now_ms)"
    elapsed_ms=$((now - start_ms))
    if (( elapsed_ms >= max_ms )); then
      echo "REPLY_WAIT done outcome=timeout elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
      echo "E_REPLY_WAIT_TIMEOUT elapsed_ms=${elapsed_ms} max_sec=${max_sec} run_id=${RUN_ID}" >&2
      return 76
    fi

    set +e
    reply_ready_probe_via_cdp
    probe_status=$?
    set -e
    if [[ $probe_status -eq 0 ]]; then
      set +e
      precheck_via_cdp
      fetch_status=$?
      set -e
      if [[ $fetch_status -eq 0 ]]; then
        echo "REPLY_WAIT done outcome=ready elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
        return 0
      fi
      if [[ $fetch_status -eq 2 ]]; then
        echo "REPLY_WAIT done outcome=route_mismatch elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
        return 2
      fi
      echo "REPLY_WAIT tick elapsed_ms=${elapsed_ms} probe_status=0 fetch_status=${fetch_status} run_id=${RUN_ID}" >&2
    elif [[ $probe_status -eq 2 ]]; then
      echo "REPLY_WAIT done outcome=route_mismatch elapsed_ms=${elapsed_ms} run_id=${RUN_ID}" >&2
      return 2
    else
      echo "REPLY_WAIT tick elapsed_ms=${elapsed_ms} probe_status=${probe_status} run_id=${RUN_ID}" >&2
    fi
    sleep "$poll_s"
  done
}

if [[ "${SKIP_PRECHECK}" == "1" ]]; then
  PRECHECK_DONE=1
  log_action "precheck" "result=skipped debug=1"
else
  log_action "precheck" "result=start"
  set +e
  precheck_via_cdp
  precheck_status=$?
  set -e

  if [[ $precheck_status -eq 11 ]] && [[ "${AUTO_WAIT_ON_GENERATION}" != "0" ]]; then
    set +e
    precheck_auto_wait_loop
    precheck_status=$?
    set -e
    if [[ $precheck_status -eq 73 ]]; then
      exit 73
    fi
  fi

  if [[ $precheck_status -eq 0 ]]; then
    PRECHECK_DONE=1
    log_action "reuse" "result=precheck_hit"
    cat "$out"
    exit 0
  fi
  if [[ $precheck_status -eq 10 ]]; then
    PRECHECK_DONE=1
    log_action "precheck" "result=no_new_reply"
  elif [[ $precheck_status -eq 11 ]]; then
    PRECHECK_DONE=1
    log_action "precheck" "result=generation_in_progress continue=1"
  elif [[ $precheck_status -eq 2 ]]; then
    echo "chatgpt_send precheck failed (route mismatch)." >&2
    exit 2
  else
    PRECHECK_DONE=1
    log_action "precheck" "result=failed status=${precheck_status} continue=1"
  fi
fi

set +e
run_send_checked "initial"
status=$?
set -e

if [[ $status -eq 6 ]]; then
  # Chrome may be running without --remote-allow-origins; restart our automation
  # Chrome instance with the correct flags.
  stale_pids="$(chrome_pids_for_profile | tr '\n' ' ' | sed 's/[[:space:]]*$//')"
  if [[ -n "${stale_pids//[[:space:]]/}" ]]; then
    echo "Restarting automation Chrome to enable CDP WebSocket access..." >&2
    for p in $stale_pids; do
      kill "$p" 2>/dev/null || true
    done
    sleep 0.8
  fi
  maybe_cdp_recover "status6_websocket_handshake" "${CHATGPT_URL:-https://chatgpt.com/}" || exit 1
  set +e
  run_send_checked "retry_status6"
  status=$?
  set -e
fi

if [[ $status -eq 1 ]]; then
  # CDP HTTP endpoint may not be ready immediately after browser launch/focus.
  # Wait briefly and retry once before failing hard.
  echo "CDP connection failed (status=1). Waiting for browser CDP to become ready..." >&2
  if ! wait_for_cdp; then
    maybe_cdp_recover "status1_initial" "${CHATGPT_URL:-https://chatgpt.com/}" || exit 1
    wait_for_cdp || true
  fi
  set +e
  run_send_checked "retry_status1"
  status=$?
  set -e
fi

tab_recover_attempted=0
if [[ $status -eq 2 || $status -eq 5 ]]; then
  tab_recover_attempted=1
  # Recover from missing/invalid active target tab or transient CDP disconnects.
  # Keep retries bounded and deterministic.
  recover_try=1
  while [[ $recover_try -le 2 ]] && [[ $status -eq 2 || $status -eq 5 ]]; do
    if [[ $status -eq 2 ]]; then
      echo "E_TAB_NOT_FOUND.retry attempt=${recover_try}" >&2
    fi
    if [[ -n "${CHATGPT_URL:-}" ]] && is_chat_conversation_url "$CHATGPT_URL"; then
      cdp_activate_or_open_url "$CHATGPT_URL" || maybe_cdp_recover "status${status}_convo_target" "$CHATGPT_URL" || exit 1
    else
      maybe_cdp_recover "status${status}_home_target" "${CHATGPT_URL:-https://chatgpt.com/}" || exit 1
    fi
    sleep 0.2
    set +e
    run_send_checked "retry_status${status}_tab_recover_${recover_try}"
    status=$?
    set -e
    recover_try=$((recover_try+1))
  done
fi

if [[ $status -eq 1 ]] && [[ $tab_recover_attempted -eq 1 ]]; then
  # One controlled recover after tab-not-found branch to avoid noisy fail loops.
  echo "E_CDP_UNREACHABLE.recover_once reason=post_tab_recover" >&2
  maybe_cdp_recover "status1_post_tab_recover" "${CHATGPT_URL:-https://chatgpt.com/}" || exit 1
  sleep 0.5
  set +e
  run_send_checked "retry_post_tab_recover"
  status=$?
  set -e
fi

if [[ $status -eq 4 ]]; then
  # Controlled one-shot retry for transient Runtime.evaluate/CDP method timeouts.
  echo "E_CDP_TIMEOUT_RETRY attempt=1" >&2
  if [[ -n "${CHATGPT_URL:-}" ]] && is_chat_conversation_url "$CHATGPT_URL"; then
    cdp_activate_or_open_url "$CHATGPT_URL" || maybe_cdp_recover "status4_timeout_convo_target" "$CHATGPT_URL" || exit 1
  else
    maybe_cdp_recover "status4_timeout_home_target" "${CHATGPT_URL:-https://chatgpt.com/}" || exit 1
  fi
  sleep 0.2
  set +e
  run_send_checked "retry_status4_timeout"
  status=$?
  set -e
fi

if [[ $status -ne 0 ]]; then
  echo "chatgpt_send failed (cdp status=$status)." >&2
  # Keep browser visible for manual inspection.
  if [[ -n "${CHATGPT_URL:-}" ]]; then
    cdp_activate_or_open_url "$CHATGPT_URL" || true
  fi
  exit $status
fi

if [[ "${REPLY_POLLING}" == "1" ]]; then
  set +e
  reply_wait_collect_via_probe
  reply_status=$?
  set -e
  if [[ $reply_status -ne 0 ]]; then
    if [[ $reply_status -eq 2 ]]; then
      echo "chatgpt_send failed (reply wait route mismatch)." >&2
      exit 2
    fi
    if [[ $reply_status -eq 76 ]]; then
      exit 76
    fi
    echo "chatgpt_send failed (reply wait status=$reply_status)." >&2
    exit "$reply_status"
  fi
fi

# Ensure the chat stays visible for the human: after automation, bring the
# conversation tab to the front in the shared Chrome.
if cdp_is_up; then
  if [[ -n "${CHATGPT_URL:-}" ]] && is_chat_conversation_url "$CHATGPT_URL"; then
    cdp_activate_or_open_url "$CHATGPT_URL" || true
    cdp_cleanup_chat_tabs "$CHATGPT_URL" || true
  fi
fi

# If we didn't have a conversation URL before (or we started from https://chatgpt.com/),
# try to pin it now (after the first message creates the conversation and the
# /c/<id> URL exists).
if [[ $has_convo_url -eq 0 ]] && cdp_is_up; then
  post_chat_urls="$(capture_chat_urls_from_cdp | sort -u || true)"
  new_chat_url=""
  new_title=""
  if [[ -n "${post_chat_urls//[[:space:]]/}" ]]; then
    # Prefer a newly-created URL (post - pre).
    if [[ -n "${pre_chat_urls//[[:space:]]/}" ]]; then
      new_chat_url="$(comm -13 <(printf '%s\n' "$pre_chat_urls") <(printf '%s\n' "$post_chat_urls") | head -n 1 || true)"
    fi
    # Fallback: if there is exactly one chat URL open, pick it.
    if [[ -z "${new_chat_url:-}" ]]; then
      if [[ "$(printf '%s\n' "$post_chat_urls" | sed '/^$/d' | wc -l)" -eq 1 ]]; then
        new_chat_url="$(printf '%s\n' "$post_chat_urls" | sed '/^$/d' | head -n 1)"
      fi
    fi
  fi
  if [[ -z "${new_chat_url:-}" ]]; then
    # Fallback for shared/multi-tab mode: pick the last visible chat tab.
    # This keeps child runs from ending with empty EVIDENCE when many chats are open.
    fallback_tab="$(capture_chat_tab_from_cdp_last || true)"
    fallback_url="${fallback_tab%%$'\t'*}"
    if [[ -n "${fallback_url:-}" ]] && [[ "$fallback_url" != "$fallback_tab" ]] && is_chat_conversation_url "$fallback_url"; then
      new_chat_url="$fallback_url"
      fallback_title="${fallback_tab#*$'\t'}"
      if [[ "$fallback_title" != "$fallback_tab" ]]; then
        new_title="$fallback_title"
      fi
    fi
  fi

  if [[ -n "${new_chat_url:-}" ]] && is_chat_conversation_url "$new_chat_url"; then
    if [[ -z "${new_title:-}" ]]; then
      new_title="$(capture_chat_title_for_url_from_cdp "$new_chat_url" | head -n 1 || true)"
    fi
    mkdir -p "$(dirname "$CHATGPT_URL_FILE")" >/dev/null 2>&1 || true
    printf '%s\n' "$new_chat_url" >"$CHATGPT_URL_FILE"
    # Save as last + active session name if needed.
    chats_db_upsert "last" "$new_chat_url" "${new_title:-}" >/dev/null 2>&1 || true
    if [[ "${EXPLICIT_HOME_PROBE}" == "1" ]]; then
      echo "[P2] active_update=skipped reason=explicit_home_probe old_active=${OLD_ACTIVE_URL:-"(none)"} new_candidate=${new_chat_url}" >&2
    else
      existing="$(chats_db_find_name_by_url "$new_chat_url" | head -n 1 || true)"
      if [[ -z "${existing:-}" ]] || [[ "$existing" == "last" ]]; then
        if [[ -n "${INIT_SESSION_NAME:-}" ]]; then
          name="$INIT_SESSION_NAME"
          title="${INIT_SESSION_TITLE:-$new_title}"
        else
          name="$(autoname)"
          title="${new_title:-}"
        fi
        name="$(chats_db_unique_name "$name")"
        chats_db_upsert "$name" "$new_chat_url" "${title:-}" >/dev/null 2>&1 || true
        chats_db_set_active "$name" >/dev/null 2>&1 || true
      else
        chats_db_set_active "$existing" >/dev/null 2>&1 || true
      fi
    fi

    # Make sure the newly created chat is visible in the browser.
    cdp_activate_or_open_url "$new_chat_url" || true
    cdp_cleanup_chat_tabs "$new_chat_url" || true
  fi
fi

if [[ "${EXPLICIT_HOME_PROBE}" == "1" ]]; then
  current_active_name="$(chats_db_get_active_name | head -n 1 || true)"
  if [[ "${current_active_name:-}" != "${OLD_ACTIVE_NAME:-}" ]]; then
    chats_db_set_active "${OLD_ACTIVE_NAME:-}" >/dev/null 2>&1 || true
    echo "[P2] active_restore=applied reason=explicit_home_probe old_active=${OLD_ACTIVE_NAME:-"(none)"} old_url=${OLD_ACTIVE_URL:-"(none)"} current_after_restore=${OLD_ACTIVE_NAME:-"(none)"}" >&2
  fi
fi

cat "$out"
