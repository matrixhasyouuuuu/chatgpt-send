#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Spawn a second Codex agent.
#
# Main use-case:
# - primary agent calls this helper
# - by default child uses the same Specialist browser/profile/cookies as primary
# - optional isolated mode gives child its own CHATGPT_SEND_ROOT + CDP port
# - optional separate terminal window launcher
# - optional wait mode to return child final message

usage() {
  cat <<'EOF'
Usage:
  spawn_second_agent --project-path PATH (--task TEXT | --task-file FILE) [options]

Required:
  --project-path PATH         Target project path for child Codex agent
  --task TEXT                 Child task text
  --task-file FILE            Child task text from file

Options:
  --iterations N              Iteration budget hint for child prompt (default: 3)
  --launcher MODE             auto|window|direct (default: auto)
  --shared-browser            Use primary browser/profile/cookies (default)
  --isolated-browser          Use separate browser/profile/cookies for child
  --browser-required          Child must use Specialist/browser and report evidence
  --browser-optional          Child may decide whether to use Specialist/browser (default)
  --browser-disabled          Child must not use Specialist/browser
  --init-specialist-chat      Create a dedicated Specialist chat for this child (default)
  --no-init-specialist-chat   Do not auto-create a dedicated Specialist chat
  --wait                      Wait for child completion and print result
  --timeout-sec N             Wait timeout in seconds (default: 3600)
  --open-browser              Open Specialist browser for child (default)
  --no-open-browser           Skip browser open
  --skip-git-repo-check       Pass --skip-git-repo-check to child codex exec (default)
  --no-skip-git-repo-check    Do not pass --skip-git-repo-check
  --log-dir PATH              Log/output directory (default: /tmp/chatgpt-send-child)
  --state-root PATH           Override CHATGPT_SEND_ROOT for child
  --cdp-port PORT             Override child CDP port
  --model MODEL               Optional model for child codex exec
  --codex-bin PATH            Codex binary (default: codex)
  --chatgpt-send-path PATH    chatgpt_send path (default: /home/matrix/projects/chatgpt-send/bin/chatgpt_send)
  --agent-id ID               Child identity label for coordinator/swarm context
  --agent-name NAME           Human-friendly child name for coordinator/swarm context
  --team-goal TEXT            Shared goal for all child agents (shown in child prompt)
  --peer TEXT                 Peer assignment line (repeatable), e.g. "agent-2: tests and verification"
  --auto-monitor              Enable background child monitor (default)
  --no-auto-monitor           Disable background child monitor
  --auto-monitor-stdout       Mirror monitor events to stdout
  --no-auto-monitor-stdout    Keep monitor events only in monitor log file (default)
  --auto-monitor-poll-sec N   Monitor poll interval (default: 2)
  --auto-monitor-heartbeat-sec N  Heartbeat interval (default: 20; 0 disables)
  --auto-monitor-timeout-sec N    Monitor timeout (default: 0, disabled)
  -h, --help                  Show help

Output:
  Prints child metadata (RUN_ID, CHILD_RUN_ID, CHILD_RUN_DIR, LOG_FILE, LAST_FILE, EXIT_FILE, STATE_ROOT, CODEX_CHATGPT_SEND_ROOT, CDP_PORT).
  In no-wait mode also prints monitor metadata (AUTO_MONITOR, MONITOR_LOG_FILE, MONITOR_PID_FILE).
  In --wait mode also prints CHILD_STATUS and CHILD_RESULT.
EOF
}

PROJECT_PATH=""
TASK_TEXT=""
TASK_FILE=""
ITERATIONS=3
LAUNCHER="auto"
WAIT_MODE=0
TIMEOUT_SEC=3600
OPEN_BROWSER=1
LOG_DIR="/tmp/chatgpt-send-child"
LOG_DIR_SET=0
STATE_ROOT=""
CDP_PORT=""
BROWSER_MODE="shared"
STATE_ROOT_SET=0
CDP_PORT_SET=0
MODEL=""
CODEX_BIN="codex"
CHATGPT_SEND_PATH="/home/matrix/projects/chatgpt-send/bin/chatgpt_send"
AGENT_ID=""
AGENT_NAME=""
TEAM_GOAL=""
declare -a TEAM_PEERS=()
BROWSER_POLICY="optional"
SKIP_GIT_REPO_CHECK=1
INIT_SPECIALIST_CHAT=1
AUTO_MONITOR="${SPAWN_AUTO_MONITOR:-1}"
AUTO_MONITOR_STDOUT="${SPAWN_AUTO_MONITOR_STDOUT:-0}"
AUTO_MONITOR_POLL_SEC="${SPAWN_AUTO_MONITOR_POLL_SEC:-2}"
AUTO_MONITOR_HEARTBEAT_SEC="${SPAWN_AUTO_MONITOR_HEARTBEAT_SEC:-20}"
AUTO_MONITOR_TIMEOUT_SEC="${SPAWN_AUTO_MONITOR_TIMEOUT_SEC:-0}"
MONITOR_SCRIPT="${SPAWN_AUTO_MONITOR_SCRIPT:-$ROOT_DIR/scripts/child_run_monitor.sh}"
FLEET_REGISTRY_FILE="${CHATGPT_SEND_FLEET_REGISTRY_FILE:-}"
FLEET_AGENT_ID="${CHATGPT_SEND_FLEET_AGENT_ID:-}"
FLEET_ATTEMPT="${CHATGPT_SEND_FLEET_ATTEMPT:-}"
FLEET_ASSIGNED_CHAT_URL="${CHATGPT_SEND_FLEET_ASSIGNED_CHAT_URL:-}"
FLEET_REGISTRY_LOCK_TIMEOUT_SEC="${CHATGPT_SEND_FLEET_REGISTRY_LOCK_TIMEOUT_SEC:-2}"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --project-path) PROJECT_PATH="${2:-}"; shift 2;;
    --task) TASK_TEXT="${2:-}"; shift 2;;
    --task-file) TASK_FILE="${2:-}"; shift 2;;
    --iterations) ITERATIONS="${2:-}"; shift 2;;
    --launcher) LAUNCHER="${2:-}"; shift 2;;
    --shared-browser) BROWSER_MODE="shared"; shift;;
    --isolated-browser) BROWSER_MODE="isolated"; shift;;
    --browser-required) BROWSER_POLICY="required"; shift;;
    --browser-optional) BROWSER_POLICY="optional"; shift;;
    --browser-disabled) BROWSER_POLICY="disabled"; shift;;
    --init-specialist-chat) INIT_SPECIALIST_CHAT=1; shift;;
    --no-init-specialist-chat) INIT_SPECIALIST_CHAT=0; shift;;
    --wait) WAIT_MODE=1; shift;;
    --timeout-sec) TIMEOUT_SEC="${2:-}"; shift 2;;
    --open-browser) OPEN_BROWSER=1; shift;;
    --no-open-browser) OPEN_BROWSER=0; shift;;
    --skip-git-repo-check) SKIP_GIT_REPO_CHECK=1; shift;;
    --no-skip-git-repo-check) SKIP_GIT_REPO_CHECK=0; shift;;
    --log-dir) LOG_DIR="${2:-}"; LOG_DIR_SET=1; shift 2;;
    --state-root) STATE_ROOT="${2:-}"; STATE_ROOT_SET=1; shift 2;;
    --cdp-port) CDP_PORT="${2:-}"; CDP_PORT_SET=1; shift 2;;
    --model) MODEL="${2:-}"; shift 2;;
    --codex-bin) CODEX_BIN="${2:-}"; shift 2;;
    --chatgpt-send-path) CHATGPT_SEND_PATH="${2:-}"; shift 2;;
    --agent-id) AGENT_ID="${2:-}"; shift 2;;
    --agent-name) AGENT_NAME="${2:-}"; shift 2;;
    --team-goal) TEAM_GOAL="${2:-}"; shift 2;;
    --peer) TEAM_PEERS+=("${2:-}"); shift 2;;
    --auto-monitor) AUTO_MONITOR=1; shift;;
    --no-auto-monitor) AUTO_MONITOR=0; shift;;
    --auto-monitor-stdout) AUTO_MONITOR_STDOUT=1; shift;;
    --no-auto-monitor-stdout) AUTO_MONITOR_STDOUT=0; shift;;
    --auto-monitor-poll-sec) AUTO_MONITOR_POLL_SEC="${2:-}"; shift 2;;
    --auto-monitor-heartbeat-sec) AUTO_MONITOR_HEARTBEAT_SEC="${2:-}"; shift 2;;
    --auto-monitor-timeout-sec) AUTO_MONITOR_TIMEOUT_SEC="${2:-}"; shift 2;;
    -h|--help) usage; exit 0;;
    *) echo "Unknown arg: $1" >&2; usage >&2; exit 2;;
  esac
done

if [[ -z "${PROJECT_PATH:-}" ]]; then
  echo "Error: --project-path is required." >&2
  exit 2
fi
if [[ -z "${TASK_TEXT:-}" ]] && [[ -z "${TASK_FILE:-}" ]]; then
  echo "Error: provide --task or --task-file." >&2
  exit 2
fi
if [[ -n "${TASK_TEXT:-}" ]] && [[ -n "${TASK_FILE:-}" ]]; then
  echo "Error: use only one of --task or --task-file." >&2
  exit 2
fi
if [[ ! "$ITERATIONS" =~ ^[0-9]+$ ]] || (( ITERATIONS < 1 )); then
  echo "Error: --iterations must be a positive integer." >&2
  exit 2
fi
if [[ ! "$TIMEOUT_SEC" =~ ^[0-9]+$ ]] || (( TIMEOUT_SEC < 1 )); then
  echo "Error: --timeout-sec must be a positive integer." >&2
  exit 2
fi
if [[ "$LAUNCHER" != "auto" && "$LAUNCHER" != "window" && "$LAUNCHER" != "direct" ]]; then
  echo "Error: --launcher must be auto|window|direct." >&2
  exit 2
fi
if [[ "$BROWSER_MODE" != "shared" && "$BROWSER_MODE" != "isolated" ]]; then
  echo "Error: browser mode must be shared|isolated." >&2
  exit 2
fi
if [[ "$BROWSER_POLICY" != "required" && "$BROWSER_POLICY" != "optional" && "$BROWSER_POLICY" != "disabled" ]]; then
  echo "Error: browser policy must be required|optional|disabled." >&2
  exit 2
fi
if [[ ! "$AUTO_MONITOR" =~ ^[01]$ ]] || [[ ! "$AUTO_MONITOR_STDOUT" =~ ^[01]$ ]]; then
  echo "Error: --auto-monitor and --auto-monitor-stdout expect 0/1 mode." >&2
  exit 2
fi
for n in "$AUTO_MONITOR_POLL_SEC" "$AUTO_MONITOR_HEARTBEAT_SEC" "$AUTO_MONITOR_TIMEOUT_SEC"; do
  if [[ ! "$n" =~ ^[0-9]+$ ]]; then
    echo "Error: auto-monitor numeric option expected, got: $n" >&2
    exit 2
  fi
done
if [[ ! "$FLEET_REGISTRY_LOCK_TIMEOUT_SEC" =~ ^[0-9]+$ ]]; then
  echo "Error: CHATGPT_SEND_FLEET_REGISTRY_LOCK_TIMEOUT_SEC must be numeric, got: $FLEET_REGISTRY_LOCK_TIMEOUT_SEC" >&2
  exit 2
fi
if (( AUTO_MONITOR_POLL_SEC < 1 )); then
  echo "Error: --auto-monitor-poll-sec must be >= 1." >&2
  exit 2
fi
# Apply browser opening policy at launcher level.
if [[ "$BROWSER_POLICY" == "disabled" ]]; then
  OPEN_BROWSER=0
  INIT_SPECIALIST_CHAT=0
elif [[ "$BROWSER_POLICY" == "required" ]]; then
  OPEN_BROWSER=1
fi
if (( WAIT_MODE == 1 )); then
  AUTO_MONITOR=0
fi

if [[ ! -d "$PROJECT_PATH" ]]; then
  echo "Error: project path does not exist: $PROJECT_PATH" >&2
  exit 2
fi
PROJECT_PATH="$(cd "$PROJECT_PATH" && pwd)"

if ! command -v "$CODEX_BIN" >/dev/null 2>&1; then
  echo "Error: codex binary not found: $CODEX_BIN" >&2
  exit 2
fi
if ! command -v python3 >/dev/null 2>&1; then
  echo "Error: python3 is required." >&2
  exit 2
fi
if (( OPEN_BROWSER == 1 )) && [[ ! -x "$CHATGPT_SEND_PATH" ]]; then
  echo "Error: chatgpt_send not executable: $CHATGPT_SEND_PATH" >&2
  exit 2
fi

if [[ -n "${TASK_FILE:-}" ]]; then
  if [[ ! -f "$TASK_FILE" ]]; then
    echo "Error: task file not found: $TASK_FILE" >&2
    exit 2
  fi
  TASK_TEXT="$(cat "$TASK_FILE")"
fi

if (( LOG_DIR_SET == 0 )) && [[ -n "${CHATGPT_SEND_LOG_DIR:-}" ]]; then
  LOG_DIR="${CHATGPT_SEND_LOG_DIR}/child"
fi

run_id="child-$(date +%Y%m%d-%H%M%S)-$$"
mkdir -p "$LOG_DIR"
LOG_DIR="$(cd "$LOG_DIR" && pwd)"
RUN_DIR="${LOG_DIR}/${run_id}"
mkdir -p "$RUN_DIR"
CHATGPT_SEND_CHILD_LOG_DIR="${RUN_DIR}/chatgpt_send"
mkdir -p "$CHATGPT_SEND_CHILD_LOG_DIR"

# Resolve canonical chatgpt_send tool root.
chatgpt_send_dir="$(cd "$(dirname "$CHATGPT_SEND_PATH")" && pwd)"
if [[ "$(basename "$chatgpt_send_dir")" == "bin" ]]; then
  chatgpt_tool_root="$(cd "$chatgpt_send_dir/.." && pwd)"
else
  chatgpt_tool_root="$chatgpt_send_dir"
fi

if (( STATE_ROOT_SET == 0 )); then
  if [[ "$BROWSER_MODE" == "shared" ]]; then
    # Shared browser/cookies, but per-child state to avoid chat URL/session collisions.
    STATE_ROOT="${chatgpt_tool_root}/state/child-agents-shared/${run_id}"
  else
    STATE_ROOT="${chatgpt_tool_root}/state/child-agents/${run_id}"
  fi
fi
mkdir -p "$STATE_ROOT/state"

# Codex child runs in workspace-write sandbox (project path + /tmp), so
# CHATGPT_SEND_ROOT used by commands inside child must be writable there.
CODEX_CHATGPT_SEND_ROOT="${PROJECT_PATH}/.chatgpt_send_child_state/${run_id}"
mkdir -p "$CODEX_CHATGPT_SEND_ROOT/state"

if [[ "$BROWSER_MODE" == "shared" ]]; then
  CHILD_PROFILE_DIR="${chatgpt_tool_root}/state/manual-login-profile"
  CHATGPT_SEND_PRESERVE_TABS_VALUE="1"
  if [[ "${CHATGPT_SEND_DISABLE_LOCK:-0}" == "1" ]]; then
    SHARED_BROWSER_LOCK_FILE=""
  elif [[ "${CHATGPT_SEND_LOCK_FILE+x}" == "x" ]]; then
    SHARED_BROWSER_LOCK_FILE="${CHATGPT_SEND_LOCK_FILE}"
  else
    # Keep lock writable from child sandbox.
    SHARED_BROWSER_LOCK_FILE="/tmp/chatgpt-send-shared-browser.lock"
  fi
else
  CHILD_PROFILE_DIR="${STATE_ROOT}/state/manual-login-profile"
  CHATGPT_SEND_PRESERVE_TABS_VALUE="0"
  SHARED_BROWSER_LOCK_FILE="${CODEX_CHATGPT_SEND_ROOT}/state/browser.lock"
fi
if [[ -n "${SHARED_BROWSER_LOCK_FILE:-}" ]]; then
  mkdir -p "$(dirname "$SHARED_BROWSER_LOCK_FILE")"
fi

# chatgpt_send expects ROOT/bin and ROOT/docs to exist when CHATGPT_SEND_ROOT is overridden.
# Provide these as symlinks to the canonical tool root for both roots.
if [[ ! -e "$STATE_ROOT/bin" ]]; then
  ln -s "$chatgpt_tool_root/bin" "$STATE_ROOT/bin"
fi
if [[ ! -e "$STATE_ROOT/docs" ]]; then
  ln -s "$chatgpt_tool_root/docs" "$STATE_ROOT/docs"
fi
if [[ ! -e "$CODEX_CHATGPT_SEND_ROOT/bin" ]]; then
  ln -s "$chatgpt_tool_root/bin" "$CODEX_CHATGPT_SEND_ROOT/bin"
fi
if [[ ! -e "$CODEX_CHATGPT_SEND_ROOT/docs" ]]; then
  ln -s "$chatgpt_tool_root/docs" "$CODEX_CHATGPT_SEND_ROOT/docs"
fi

choose_port() {
  python3 - <<'PY'
import socket
for port in range(9330, 9400):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        s.bind(("127.0.0.1", port))
    except OSError:
        s.close()
        continue
    s.close()
    print(port)
    raise SystemExit(0)
raise SystemExit(1)
PY
}

if (( CDP_PORT_SET == 0 )); then
  if [[ "$BROWSER_MODE" == "shared" ]]; then
    CDP_PORT="${CHATGPT_SEND_CDP_PORT:-9222}"
  else
    CDP_PORT="$(choose_port || true)"
  fi
fi
if [[ -z "${CDP_PORT:-}" ]] || [[ ! "$CDP_PORT" =~ ^[0-9]+$ ]]; then
  echo "Error: could not resolve child CDP port." >&2
  exit 2
fi

prompt_file="$RUN_DIR/${run_id}.prompt.txt"
log_file="$RUN_DIR/${run_id}.log"
last_file="$RUN_DIR/${run_id}.last.txt"
exit_file="$RUN_DIR/${run_id}.exit"
pid_file="$RUN_DIR/${run_id}.pid"
runner_file="$RUN_DIR/${run_id}.runner.sh"
status_file="$RUN_DIR/${run_id}.status.log"
child_result_file="$RUN_DIR/child_result.json"

child_identity_label=""
if [[ -n "${AGENT_ID:-}" ]] && [[ -n "${AGENT_NAME:-}" ]]; then
  child_identity_label="${AGENT_ID} (${AGENT_NAME})"
elif [[ -n "${AGENT_ID:-}" ]]; then
  child_identity_label="${AGENT_ID}"
elif [[ -n "${AGENT_NAME:-}" ]]; then
  child_identity_label="${AGENT_NAME}"
else
  child_identity_label="${run_id}"
fi
team_goal_effective="${TEAM_GOAL:-${TASK_TEXT}}"
peer_lines_block="none"
if (( ${#TEAM_PEERS[@]} > 0 )); then
  peer_lines_block=""
  for peer_line in "${TEAM_PEERS[@]}"; do
    [[ -n "${peer_line//[[:space:]]/}" ]] || continue
    peer_lines_block+="- ${peer_line}"$'\n'
  done
  peer_lines_block="${peer_lines_block%$'\n'}"
  [[ -n "${peer_lines_block//[[:space:]]/}" ]] || peer_lines_block="none"
fi

cat >"$prompt_file" <<EOF
Ты второй агент (child agent), запущенный главным агентом.

Контекст:
- Project path: ${PROJECT_PATH}
- Child identity: ${child_identity_label}
- Team goal (shared): ${team_goal_effective}
- Peer assignments (swarm context):
${peer_lines_block}
- User task: ${TASK_TEXT}
- Target iterations hint: ${ITERATIONS}
- Browser policy: ${BROWSER_POLICY}

ОБЯЗАТЕЛЬНО:
1) Работай в ${PROJECT_PATH}.
2) Не меняй цель пользователя и не подменяй задачу: выполни именно User task.
3) Для Specialist используй /home/matrix/projects/chatgpt-send/bin/chatgpt_send с переменными окружения CHATGPT_SEND_ROOT и CHATGPT_SEND_CDP_PORT.
4) Пиши ВСЕ сообщения и финальный ответ только на русском языке.
5) Даже если команды/логи на английском, объяснения, выводы и план всегда пиши по-русски.
6) В ответе перед финалом обязательно дай строку формата:
   CHILD_BROWSER_USED: <yes|no> ; REASON: <why> ; EVIDENCE: <chat-url-or-none>
7) Если Browser policy=required:
   - ты обязан реально использовать Specialist минимум один раз;
   - первое сообщение в Specialist должно кратко передать: цель задачи, что уже известно, что нужно проверить по фактам;
   - используй Specialist как "внешний мозг": актуальные документы/интернет, проверка рисков, проверяемые шаги.
8) Если Browser policy=disabled, не используй Specialist/browser вообще.
9) Не выдумывай новый scope и не подменяй задачу.
10) Работайте как "рой": учитывай, что другие child-агенты делают свои части. Жестких запретов нет.
11) Если видишь, что соседний агент уже закрыл часть работы:
   - не дублируй вслепую;
   - переключись на свою часть, проверку, тесты, интеграцию или фиксацию рисков;
   - коротко отметь это в отчёте как overlap/coordination.
12) Для контроля главного агента перед финалом обязательно дай строки:
   - CHILD_FILES_TOUCHED: <comma-separated paths | none>
   - CHILD_OVERLAP: <none | что пересеклось и что сделал>
   - CHILD_CHECKS: <какие проверки/тесты запускал | none>
13) Сделай задачу и в финале дай короткий результат для главного агента.
14) Последняя строка ответа должна начинаться так: CHILD_RESULT:
EOF

cat >"$runner_file" <<EOF
#!/usr/bin/env bash
set -euo pipefail
export CHATGPT_SEND_ROOT='${CODEX_CHATGPT_SEND_ROOT}'
export CHATGPT_SEND_CDP_PORT='${CDP_PORT}'
export CHATGPT_SEND_PROFILE_DIR='${CHILD_PROFILE_DIR}'
export CHATGPT_SEND_PRESERVE_TABS='${CHATGPT_SEND_PRESERVE_TABS_VALUE}'
export CHATGPT_SEND_LOCK_FILE='${SHARED_BROWSER_LOCK_FILE}'
export CHATGPT_SEND_LOCK_TIMEOUT_SEC='180'
export CHATGPT_SEND_AUTO_TIMEOUT_SEC='${CHATGPT_SEND_AUTO_TIMEOUT_SEC:-120}'
export CHATGPT_SEND_MAX_CDP_SLOTS='${CHATGPT_SEND_MAX_CDP_SLOTS:-2}'
export CHATGPT_SEND_SLOT_WAIT_TIMEOUT_SEC='${CHATGPT_SEND_SLOT_WAIT_TIMEOUT_SEC:-180}'
export CHATGPT_SEND_RUN_ID="\${CHATGPT_SEND_RUN_ID:-${run_id}}"
export CHATGPT_SEND_LOG_DIR="\${CHATGPT_SEND_LOG_DIR:-${CHATGPT_SEND_CHILD_LOG_DIR}}"
export CHATGPT_SEND_TRANSPORT="\${CHATGPT_SEND_TRANSPORT:-${CHATGPT_SEND_TRANSPORT:-cdp}}"
CHILD_RESULT_JSON='${child_result_file}'
STARTED_AT_ISO="\$(date -Iseconds)"
STARTED_AT_EPOCH="\$(date +%s)"
STATUS="UNKNOWN"
SLOT_USED=0
BROWSER_USED=0
BROWSER_EVIDENCE_WRITTEN=0
: > '${status_file}'
echo \$\$ > '${pid_file}'

now_ms() {
  date +%s%3N 2>/dev/null || python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
}

iter_status() {
  local step="\$1"
  local status="\$2"
  local reason="\$3"
  local ts_ms
  ts_ms="\$(now_ms)"
  local line="[child] ITER_STATUS step=\${step} status=\${status} reason=\${reason} ts_ms=\${ts_ms} run_id=${run_id} child_id=${run_id} pinned_url=\${CHATGPT_SEND_FORCE_CHAT_URL:-none}"
  echo "\${line}" >> '${log_file}'
  echo "\${line}" >> '${status_file}'
}

flow_ok() {
  local phase="\$1"
  local ts_ms
  ts_ms="\$(now_ms)"
  local line="[child] FLOW_OK phase=\${phase} ts_ms=\${ts_ms} run_id=${run_id} child_id=${run_id}"
  echo "\${line}" >> '${log_file}'
  echo "\${line}" >> '${status_file}'
}

{
  echo "[child] run_id=${run_id}"
  echo "[child] project=${PROJECT_PATH}"
  echo "[child] state_root=\${CHATGPT_SEND_ROOT}"
  echo "[child] coordinator_state_root=${STATE_ROOT}"
  echo "[child] cdp_port=\${CHATGPT_SEND_CDP_PORT}"
  echo "[child] profile_dir=\${CHATGPT_SEND_PROFILE_DIR}"
  echo "[child] preserve_tabs=\${CHATGPT_SEND_PRESERVE_TABS}"
  echo "[child] lock_file=\${CHATGPT_SEND_LOCK_FILE}"
  echo "[child] run_id_env=\${CHATGPT_SEND_RUN_ID}"
  echo "[child] log_dir_env=\${CHATGPT_SEND_LOG_DIR}"
  echo "[child] chatgpt_send_transport=\${CHATGPT_SEND_TRANSPORT:-cdp}"
  echo "[child] chatgpt_send_log_dir=${CHATGPT_SEND_CHILD_LOG_DIR}"
  echo "[child] auto_timeout=\${CHATGPT_SEND_AUTO_TIMEOUT_SEC}"
  echo "[child] started_at=\${STARTED_AT_ISO}"
} >> '${log_file}'
iter_status "bootstrap" "done" "runner_started"
if [[ '${BROWSER_POLICY}' == 'disabled' ]]; then
  echo "[child] SLOT_SKIP reason=browser_disabled mode=global run_id=${run_id} child_id=${run_id}" >> '${log_file}'
fi

write_child_result_json() {
  local rc="\$1"
  local finished_at_iso="\$2"
  local duration_sec="\$3"
  local status_value="\${STATUS:-UNKNOWN}"

  if [[ -f '${log_file}' ]] && grep -q 'CHILD_BROWSER_USED:' '${log_file}'; then
    BROWSER_USED=1
  elif [[ -f '${last_file}' ]] && grep -q 'CHILD_BROWSER_USED:' '${last_file}'; then
    BROWSER_USED=1
  else
    BROWSER_USED=0
  fi

  if [[ "\${rc}" == "0" ]]; then
    status_value="OK"
  elif [[ -z "\${status_value}" ]] || [[ "\${status_value}" == "UNKNOWN" ]]; then
    status_value="E_CHILD_FAILED"
  fi
  if [[ '${BROWSER_POLICY}' == 'required' ]] && [[ "\${BROWSER_USED}" != "1" ]] && [[ "\${rc}" != "0" ]]; then
    status_value="E_CHILD_BROWSER_REQUIRED_NOT_USED"
  fi

  python3 - "\${CHILD_RESULT_JSON}" '${run_id}' "\${status_value}" "\${rc}" '${BROWSER_POLICY}' "\${BROWSER_USED}" "\${SLOT_USED}" "\${child_chat_url:-}" "\${CHATGPT_SEND_FORCE_CHAT_URL:-}" "\${STARTED_AT_ISO}" "\${finished_at_iso}" "\${duration_sec}" '${log_file}' <<'PY'
import json
import pathlib
import sys

out_path = pathlib.Path(sys.argv[1])
run_id = sys.argv[2]
status = sys.argv[3]
exit_code = int(sys.argv[4])
browser_policy = sys.argv[5]
browser_used = sys.argv[6] == "1"
slot_used = sys.argv[7] == "1"
specialist_chat_url = sys.argv[8]
pinned_route_url = sys.argv[9]
started_at = sys.argv[10]
finished_at = sys.argv[11]
duration_sec = int(sys.argv[12])
log_path = sys.argv[13]

payload = {
    "run_id": run_id,
    "status": status,
    "exit_code": exit_code,
    "browser_policy": browser_policy,
    "browser_used": browser_used,
    "slot_used": slot_used,
    "specialist_chat_url": specialist_chat_url,
    "pinned_route_url": pinned_route_url,
    "started_at": started_at,
    "finished_at": finished_at,
    "duration_sec": duration_sec,
    "log_path": log_path,
}
out_path.parent.mkdir(parents=True, exist_ok=True)
out_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
PY
}

child_finalize() {
  local rc=\$?
  local finished_at_iso="\$(date -Iseconds)"
  local finished_at_epoch="\$(date +%s)"
  local duration_sec=0
  if [[ "\${finished_at_epoch}" =~ ^[0-9]+$ ]] && [[ "\${STARTED_AT_EPOCH}" =~ ^[0-9]+$ ]] && (( finished_at_epoch >= STARTED_AT_EPOCH )); then
    duration_sec=\$((finished_at_epoch - STARTED_AT_EPOCH))
  fi
  if [[ -f '${status_file}' ]]; then
    cat '${status_file}' >> '${last_file}' 2>/dev/null || true
  fi
  echo "\${rc}" > '${exit_file}'
  echo "[child] exit_code=\${rc}" >> '${log_file}'
  echo "[child] finished_at=\${finished_at_iso}" >> '${log_file}'
  write_child_result_json "\${rc}" "\${finished_at_iso}" "\${duration_sec}" || echo "[child] child_result_json_write=failed path=\${CHILD_RESULT_JSON}" >> '${log_file}'
}
trap child_finalize EXIT

run_chatgpt_send() {
  local max_slots="\${CHATGPT_SEND_MAX_CDP_SLOTS:-2}"
  local wait_timeout="\${CHATGPT_SEND_SLOT_WAIT_TIMEOUT_SEC:-180}"
  local slot_id=""
  local slot_fd=""
  local slot_wait_start_ms=""
  local slot_acquire_ms=""
  local slot_hold_start_ms=""
  local st=0
  local slot_wait_s0=""
  local now_s=""
  local i=0
  local slot_file=""
  local fd=""
  local wait_ms=0
  local slot_release_ms=0
  local held_ms=0
  local errexit_restore=0

  if [[ \$- == *e* ]]; then
    errexit_restore=1
  fi

  now_ms() {
    date +%s%3N 2>/dev/null || python3 - <<'PY'
import time
print(int(time.time()*1000))
PY
  }

  if [[ ! "\${max_slots}" =~ ^[0-9]+$ ]] || (( max_slots < 1 )); then
    max_slots=2
  fi
  if [[ ! "\${wait_timeout}" =~ ^[0-9]+$ ]] || (( wait_timeout < 1 )); then
    wait_timeout=180
  fi

  if [[ '${BROWSER_POLICY}' == 'disabled' ]]; then
    echo "[child] SLOT_SKIP reason=browser_disabled run_id=${run_id} child_id=${run_id}" >> '${log_file}'
    set +e
    '${CHATGPT_SEND_PATH}' "\$@"
    st=\$?
    if (( errexit_restore == 1 )); then
      set -e
    else
      set +e
    fi
    return "\${st}"
  fi

  slot_wait_start_ms="\$(now_ms)"
  while true; do
    for ((i=0; i<max_slots; i++)); do
      slot_file="/tmp/chatgpt-send-cdp-slot.\${i}.lock"
      exec {fd}>"\${slot_file}" || continue
      if flock -n "\${fd}"; then
        slot_id="\${i}"
        slot_fd="\${fd}"
        slot_acquire_ms="\$(now_ms)"
        slot_hold_start_ms="\${slot_acquire_ms}"
        SLOT_USED=1
        wait_ms=\$((slot_acquire_ms - slot_wait_start_ms))
        echo "[child] SLOT_ACQUIRE slot=\${slot_id} wait_ms=\${wait_ms} ts_ms=\${slot_acquire_ms} run_id=${run_id} child_id=${run_id}" >> '${log_file}'
        break 2
      fi
      exec {fd}>&- || true
    done
    now_s="\$(date +%s)"
    if [[ -z "\${slot_wait_s0:-}" ]]; then
      slot_wait_s0="\${now_s}"
    fi
    if (( now_s - slot_wait_s0 >= wait_timeout )); then
      STATUS="E_SLOT_ACQUIRE_TIMEOUT"
      echo "[child] E_SLOT_ACQUIRE_TIMEOUT wait_timeout_sec=\${wait_timeout} run_id=${run_id}" >> '${log_file}'
      return 73
    fi
    sleep 0.05
  done

  set +e
  '${CHATGPT_SEND_PATH}' "\$@"
  st=\$?
  if (( errexit_restore == 1 )); then
    set -e
  else
    set +e
  fi

  if [[ -n "\${slot_fd:-}" ]]; then
    slot_release_ms="\$(now_ms)"
    held_ms=\$((slot_release_ms - slot_hold_start_ms))
    echo "[child] SLOT_RELEASE slot=\${slot_id} held_ms=\${held_ms} ts_ms=\${slot_release_ms}" >> '${log_file}'
    flock -u "\${slot_fd}" >/dev/null 2>&1 || true
    exec {slot_fd}>&- || true
  fi
  return "\${st}"
}

emit_browser_used_once() {
  local op="\$1"
  local rc="\${2:-0}"
  local evidence=""
  local marker=""

  if [[ "\${BROWSER_EVIDENCE_WRITTEN}" == "1" ]]; then
    return 0
  fi
  if [[ "\${CHATGPT_SEND_TRANSPORT:-cdp}" != "cdp" ]]; then
    return 0
  fi
  if [[ '${BROWSER_POLICY}' == 'disabled' ]]; then
    return 0
  fi
  if [[ "\${rc}" != "0" ]]; then
    return 0
  fi

  if [[ -n "\${CHATGPT_SEND_FORCE_CHAT_URL:-}" ]] && [[ "\${CHATGPT_SEND_FORCE_CHAT_URL}" =~ ^https://chatgpt\.com/c/[A-Za-z0-9-]+$ ]]; then
    evidence="\${CHATGPT_SEND_FORCE_CHAT_URL}"
  elif [[ -n "\${child_chat_url:-}" ]] && [[ "\${child_chat_url}" =~ ^https://chatgpt\.com/c/[A-Za-z0-9-]+$ ]]; then
    evidence="\${child_chat_url}"
  fi
  if [[ -z "\${evidence}" ]]; then
    return 0
  fi

  marker="CHILD_BROWSER_USED: yes ; REASON: chatgpt_send_ok ; EVIDENCE: \${evidence} ; OP: \${op}"
  echo "[child] \${marker}" >> '${log_file}'
  BROWSER_EVIDENCE_WRITTEN=1
}

run_chatgpt_send_logged() {
  local step="\$1"
  shift
  local stream_log='${CHATGPT_SEND_CHILD_LOG_DIR}/transport.log'
  local tmp_out=""
  local tmp_err=""
  local errexit_restore=0
  if [[ \$- == *e* ]]; then
    errexit_restore=1
  fi
  echo "[child] step=\${step} cmd=\$*" >> '${log_file}'
  mkdir -p "\$(dirname "\${stream_log}")"
  tmp_out="\$(mktemp '${RUN_DIR}/chatgpt_send.'"'"'\${step}'"'"'.out.XXXXXX')"
  tmp_err="\$(mktemp '${RUN_DIR}/chatgpt_send.'"'"'\${step}'"'"'.err.XXXXXX')"
  set +e
  run_chatgpt_send "\$@" >"\${tmp_out}" 2>"\${tmp_err}"
  local rc=\$?
  if (( errexit_restore == 1 )); then
    set -e
  else
    set +e
  fi
  cat "\${tmp_out}" >> '${log_file}' 2>/dev/null || true
  cat "\${tmp_err}" >> '${log_file}' 2>/dev/null || true
  cat "\${tmp_out}" >> "\${stream_log}" 2>/dev/null || true
  cat "\${tmp_err}" >> "\${stream_log}" 2>/dev/null || true
  rm -f "\${tmp_out}" "\${tmp_err}" 2>/dev/null || true
  emit_browser_used_once "\${step}" "\${rc}"
  echo "[child] step=\${step} rc=\${rc}" >> '${log_file}'
  if [[ "\${rc}" == "0" ]]; then
    iter_status "\${step}" "done" "chatgpt_send_rc=0"
  else
    iter_status "\${step}" "blocked" "chatgpt_send_rc=\${rc}"
  fi
  return "\$rc"
}

run_chatgpt_send_capture() {
  local step="\$1"
  shift
  local out=""
  local stream_log='${CHATGPT_SEND_CHILD_LOG_DIR}/transport.log'
  local tmp_out=""
  local tmp_err=""
  local errexit_restore=0
  if [[ \$- == *e* ]]; then
    errexit_restore=1
  fi
  echo "[child] step=\${step} cmd=\$*" >> '${log_file}'
  mkdir -p "\$(dirname "\${stream_log}")"
  tmp_out="\$(mktemp '${RUN_DIR}/chatgpt_send.'"'"'\${step}'"'"'.out.XXXXXX')"
  tmp_err="\$(mktemp '${RUN_DIR}/chatgpt_send.'"'"'\${step}'"'"'.err.XXXXXX')"
  set +e
  run_chatgpt_send "\$@" >"\${tmp_out}" 2>"\${tmp_err}"
  local rc=\$?
  if (( errexit_restore == 1 )); then
    set -e
  else
    set +e
  fi
  out="\$(cat "\${tmp_out}" 2>/dev/null || true)"
  cat "\${tmp_out}" >> '${log_file}' 2>/dev/null || true
  cat "\${tmp_err}" >> '${log_file}' 2>/dev/null || true
  cat "\${tmp_out}" >> "\${stream_log}" 2>/dev/null || true
  cat "\${tmp_err}" >> "\${stream_log}" 2>/dev/null || true
  rm -f "\${tmp_out}" "\${tmp_err}" 2>/dev/null || true
  emit_browser_used_once "\${step}" "\${rc}"
  echo "[child] step=\${step} rc=\${rc} out=\${out}" >> '${log_file}'
  if [[ "\${rc}" == "0" ]]; then
    iter_status "\${step}" "done" "chatgpt_send_capture_rc=0"
  else
    iter_status "\${step}" "blocked" "chatgpt_send_capture_rc=\${rc}"
  fi
  printf '%s\n' "\$out"
  return "\$rc"
}

cd '${PROJECT_PATH}'
child_chat_url=""
if [[ '${OPEN_BROWSER}' == '1' ]]; then
  if [[ '${BROWSER_POLICY}' == 'required' ]]; then
    run_chatgpt_send_logged "open-browser" --open-browser --chatgpt-url https://chatgpt.com/
  else
    run_chatgpt_send_logged "open-browser" --open-browser --chatgpt-url https://chatgpt.com/ || true
  fi
fi

if [[ '${INIT_SPECIALIST_CHAT}' == '1' ]]; then
  child_topic="child-${run_id}"
  if [[ '${BROWSER_POLICY}' == 'required' ]]; then
    init_rc=0
    run_chatgpt_send_logged "init-specialist" --timeout 120 --init-specialist --topic "\${child_topic}" || init_rc=\$?
    if [[ "\${init_rc}" != "0" ]]; then
      echo "[child] step=init-specialist note=non_fatal_failure rc=\${init_rc}; continue_with_fallback" >> '${log_file}'
    fi
    run_chatgpt_send_logged "sync-chat-url" --sync-chatgpt-url || true
    child_chat_url="\$(run_chatgpt_send_capture "show-chat-url" --show-chatgpt-url | tail -n 1 || true)"
    echo "[child] specialist_chat_url=\${child_chat_url}" >> '${log_file}'
  else
    run_chatgpt_send_logged "init-specialist" --timeout 120 --init-specialist --topic "\${child_topic}" || true
    run_chatgpt_send_logged "sync-chat-url" --sync-chatgpt-url || true
    child_chat_url="\$(run_chatgpt_send_capture "show-chat-url" --show-chatgpt-url | tail -n 1 || true)"
    echo "[child] specialist_chat_url=\${child_chat_url}" >> '${log_file}'
  fi
fi

if [[ '${BROWSER_POLICY}' != 'disabled' ]] && [[ -z "\${child_chat_url:-}" ]]; then
  child_chat_url="\$(run_chatgpt_send_capture "show-chat-url" --show-chatgpt-url | tail -n 1 || true)"
  if [[ -n "\${child_chat_url:-}" ]]; then
    echo "[child] specialist_chat_url=\${child_chat_url}" >> '${log_file}'
  fi
fi
if [[ -n "\${child_chat_url:-}" ]] && [[ "\${child_chat_url}" =~ ^https://chatgpt\\.com/c/[A-Za-z0-9-]+$ ]]; then
  export CHATGPT_SEND_FORCE_CHAT_URL="\${child_chat_url}"
  echo "[child] pinned_route_url=\${CHATGPT_SEND_FORCE_CHAT_URL}" >> '${log_file}'
  cat >> '${prompt_file}' <<PINNED_ROUTE
12) Для каждого вызова /home/matrix/projects/chatgpt-send/bin/chatgpt_send с отправкой сообщения ( --prompt / --prompt-file ) обязательно указывай явный --chatgpt-url '\${child_chat_url}'.
PINNED_ROUTE
fi

set +e
extra_git_arg=""
if [[ '${SKIP_GIT_REPO_CHECK}' == '1' ]]; then
  extra_git_arg="--skip-git-repo-check"
fi

if [[ -n '${MODEL}' ]]; then
  flow_ok "read"
  '${CODEX_BIN}' exec --full-auto \${extra_git_arg} -m '${MODEL}' -C '${PROJECT_PATH}' -o '${last_file}' - < '${prompt_file}' 2>&1 | tee -a '${log_file}'
  st=\${PIPESTATUS[0]}
else
  flow_ok "read"
  '${CODEX_BIN}' exec --full-auto \${extra_git_arg} -C '${PROJECT_PATH}' -o '${last_file}' - < '${prompt_file}' 2>&1 | tee -a '${log_file}'
  st=\${PIPESTATUS[0]}
fi
set -e
if [[ "\${st}" == "0" ]]; then
  flow_ok "execute"
fi

# Enforce browser policy from child final message/logs.
browser_line=""
if [[ -f '${last_file}' ]]; then
  browser_line="\$(grep -Eo 'CHILD_BROWSER_USED:.*' '${last_file}' | tail -n 1 || true)"
fi
if [[ -z "\${browser_line:-}" ]] && [[ -f '${log_file}' ]]; then
  browser_line="\$(grep -Eo 'CHILD_BROWSER_USED:.*' '${log_file}' | tail -n 1 || true)"
fi
prompt_cmd_count="\$(grep -Ec 'chatgpt_send[^[:cntrl:]]*--prompt' '${log_file}' || true)"
chat_url_line="\$(grep -Eo 'specialist_chat_url=https://chatgpt\\.com/c/[A-Za-z0-9-]+' '${log_file}' | tail -n 1 || true)"
has_browser_evidence=0
if [[ "\${browser_line}" =~ EVIDENCE:[[:space:]]*https://chatgpt\.com/c/ ]]; then
  has_browser_evidence=1
fi
policy_fail_code=0

if [[ '${BROWSER_POLICY}' == 'required' ]]; then
  # Do not fail solely because early URL sync did not return /c/... .
  # If child later proves real browser usage with chat evidence, policy is satisfied.
  if [[ '${INIT_SPECIALIST_CHAT}' == '1' ]] && [[ -z "\${chat_url_line}" ]] && [[ "\${has_browser_evidence}" == "0" ]] && [[ "\${prompt_cmd_count}" == "0" ]]; then
    policy_fail_code=45
  fi
  if [[ "\${prompt_cmd_count}" == "0" ]] && [[ "\${has_browser_evidence}" == "0" ]]; then
    if [[ "\${policy_fail_code}" == "0" ]]; then
      policy_fail_code=44
    fi
  fi
  if [[ ! "\${browser_line}" =~ CHILD_BROWSER_USED:[[:space:]]*yes ]]; then
    if [[ "\${policy_fail_code}" == "0" ]]; then
      policy_fail_code=41
    fi
  fi
  if [[ ! "\${browser_line}" =~ EVIDENCE:[[:space:]]*https://chatgpt\.com/c/ ]]; then
    if [[ "\${policy_fail_code}" == "0" ]]; then
      policy_fail_code=42
    fi
  fi
elif [[ '${BROWSER_POLICY}' == 'disabled' ]]; then
  if [[ "\${browser_line}" =~ CHILD_BROWSER_USED:[[:space:]]*yes ]]; then
    policy_fail_code=43
  fi
fi

if [[ "\${policy_fail_code}" != "0" ]]; then
  case "\${policy_fail_code}" in
    41) STATUS="E_CHILD_BROWSER_REQUIRED_NOT_USED" ;;
    42) STATUS="E_CHILD_BROWSER_REQUIRED_NO_EVIDENCE" ;;
    43) STATUS="E_CHILD_BROWSER_DISABLED_VIOLATION" ;;
    44) STATUS="E_CHILD_BROWSER_REQUIRED_NO_PROMPT" ;;
    45) STATUS="E_CHILD_BROWSER_REQUIRED_NO_CHAT_URL" ;;
    *) STATUS="E_CHILD_BROWSER_POLICY_FAILED" ;;
  esac
  echo "[child] browser_policy_check=failed code=\${policy_fail_code} prompt_cmd_count=\${prompt_cmd_count} line=\${browser_line}" >> '${log_file}'
  st="\${policy_fail_code}"
fi

# Mark common transient infra failures explicitly in child logs.
if [[ -f '${log_file}' ]] && grep -q 'Timed out waiting for assistant response activity' '${log_file}'; then
  if [[ "\${STATUS}" == "UNKNOWN" ]]; then
    STATUS="E_ACTIVITY_TIMEOUT"
  fi
  echo "[child] error_code=E_ACTIVITY_TIMEOUT reason=assistant_activity_timeout original_exit=\${st}" >> '${log_file}'
elif [[ -f '${last_file}' ]] && grep -q 'Timed out waiting for assistant response activity' '${last_file}'; then
  if [[ "\${STATUS}" == "UNKNOWN" ]]; then
    STATUS="E_ACTIVITY_TIMEOUT"
  fi
  echo "[child] error_code=E_ACTIVITY_TIMEOUT reason=assistant_activity_timeout original_exit=\${st}" >> '${log_file}'
fi
if [[ "\${st}" == "70" ]] || ( [[ -f '${log_file}' ]] && grep -q 'Failed to acquire chatgpt_send lock within' '${log_file}' ); then
  if [[ "\${STATUS}" == "UNKNOWN" ]]; then
    STATUS="E_LOCK_TIMEOUT"
  fi
  echo "[child] error_code=E_LOCK_TIMEOUT reason=lock_timeout original_exit=\${st}" >> '${log_file}'
fi

# Codex may return non-zero on rollout-recorder shutdown even after producing
# a valid final CHILD_RESULT. Keep successful handoffs stable for coordinator.
if [[ "\${st}" != "0" ]] \
  && [[ "\${policy_fail_code}" == "0" ]] \
  && [[ "\${st}" != "70" ]] \
  && [[ "\${st}" != "41" ]] && [[ "\${st}" != "42" ]] && [[ "\${st}" != "43" ]] && [[ "\${st}" != "44" ]] && [[ "\${st}" != "45" ]] \
  && [[ -f '${last_file}' ]] \
  && grep -q '^CHILD_RESULT:' '${last_file}'; then
  echo "[child] normalized_exit=0 reason=child_result_present original_exit=\${st}" >> '${log_file}'
  st=0
fi

flow_read_ln="\$(grep -n 'FLOW_OK phase=read' '${status_file}' | head -n 1 | cut -d: -f1 || true)"
flow_exec_ln="\$(grep -n 'FLOW_OK phase=execute' '${status_file}' | head -n 1 | cut -d: -f1 || true)"
flow_report_ln="\$(grep -n 'FLOW_OK phase=report' '${status_file}' | head -n 1 | cut -d: -f1 || true)"
flow_violation=0
flow_violation_reason=""
if [[ -n "\${flow_exec_ln:-}" ]] && { [[ -z "\${flow_read_ln:-}" ]] || (( flow_exec_ln < flow_read_ln )); }; then
  flow_violation=1
  flow_violation_reason="execute_without_read"
fi
if [[ -n "\${flow_report_ln:-}" ]] && { [[ -z "\${flow_exec_ln:-}" ]] || (( flow_report_ln < flow_exec_ln )); }; then
  flow_violation=1
  if [[ -n "\${flow_violation_reason:-}" ]]; then
    flow_violation_reason="\${flow_violation_reason},report_without_execute"
  else
    flow_violation_reason="report_without_execute"
  fi
fi
if [[ "\${flow_violation}" == "1" ]]; then
  STATUS="E_FLOW_ORDER_VIOLATION"
  echo "[child] E_FLOW_ORDER_VIOLATION reason=\${flow_violation_reason}" >> '${log_file}'
  iter_status "flow-order" "blocked" "E_FLOW_ORDER_VIOLATION:\${flow_violation_reason}"
  if [[ '${BROWSER_POLICY}' == 'required' ]] && [[ "\${st}" == "0" ]]; then
    st=46
  fi
fi

if [[ "\${st}" == "0" ]]; then
  iter_status "final" "done" "child_completed"
  flow_ok "report"
  if [[ -n "\${child_chat_url:-}" ]] && [[ "\${child_chat_url}" =~ ^https://chatgpt\.com/c/[A-Za-z0-9-]+$ ]]; then
    set +e
    run_chatgpt_send --ack --chatgpt-url "\${child_chat_url}" >> '${log_file}' 2>&1
    ack_rc=\$?
    set -e
    if [[ "\${ack_rc}" == "0" ]]; then
      echo "[child] ack_status=done chat_url=\${child_chat_url}" >> '${log_file}'
    else
      echo "[child] ack_status=failed rc=\${ack_rc} chat_url=\${child_chat_url}" >> '${log_file}'
    fi
  fi
else
  if [[ -f '${log_file}' ]] && grep -q 'E_PRECHECK_GENERATION_IN_PROGRESS' '${log_file}'; then
    iter_status "final" "waiting" "generation_in_progress rc=\${st}"
  else
    iter_status "final" "blocked" "child_exit=\${st}"
  fi
  if [[ "\${STATUS}" == "UNKNOWN" ]]; then
    STATUS="E_CHILD_FAILED"
  fi
fi

exit \$st
EOF
chmod +x "$runner_file"

resolve_launcher() {
  if [[ "$LAUNCHER" == "direct" ]]; then
    echo "direct"
    return 0
  fi
  if [[ "$LAUNCHER" == "window" ]]; then
    echo "window"
    return 0
  fi
  if command -v gnome-terminal >/dev/null 2>&1 && [[ -n "${DISPLAY:-}" ]]; then
    echo "window"
    return 0
  fi
  echo "direct"
}

append_fleet_registry() {
  local registry_file="${FLEET_REGISTRY_FILE:-}"
  if [[ -z "$registry_file" ]]; then
    return 0
  fi
  mkdir -p "$(dirname "$registry_file")"
  local assigned_chat="${FLEET_ASSIGNED_CHAT_URL:-${CHATGPT_SEND_FORCE_CHAT_URL:-}}"
  local payload=""
  payload="$(python3 - \
    "$run_id" "$RUN_DIR" "$pid_file" "$exit_file" "$status_file" "$child_result_file" \
    "$log_file" "$last_file" "$FLEET_AGENT_ID" "$FLEET_ATTEMPT" "$assigned_chat" <<'PY'
import json
import sys
from datetime import datetime, timezone

run_id, run_dir, pid_file, exit_file, status_file, result_json, log_file, last_file, agent_id, attempt, assigned_chat = sys.argv[1:12]
obj = {
    "run_id": run_id,
    "run_dir": run_dir,
    "pid_file": pid_file,
    "exit_file": exit_file,
    "status_file": status_file,
    "result_json": result_json,
    "log_file": log_file,
    "last_file": last_file,
    "agent_id": agent_id or "",
    "attempt": int(attempt) if attempt.isdigit() else None,
    "assigned_chat_url": assigned_chat or "",
    "ts": datetime.now(timezone.utc).isoformat(),
}
print(json.dumps(obj, ensure_ascii=False))
PY
)"
  if [[ -z "$payload" ]]; then
    return 0
  fi
  local registry_lock="${registry_file}.lock"
  local reg_fd=""
  exec {reg_fd}>>"$registry_lock" || true
  if [[ -n "$reg_fd" ]]; then
    if ! flock -w "$FLEET_REGISTRY_LOCK_TIMEOUT_SEC" "$reg_fd" >/dev/null 2>&1; then
      echo "W_FLEET_REGISTRY_LOCK_TIMEOUT file=${registry_file} timeout_sec=${FLEET_REGISTRY_LOCK_TIMEOUT_SEC} run_id=${run_id}" >&2
      exec {reg_fd}>&- || true
      return 0
    fi
  fi
  printf '%s\n' "$payload" >>"$registry_file"
  if [[ -n "$reg_fd" ]]; then
    exec {reg_fd}>&- || true
  fi
}

launcher_mode="$(resolve_launcher)"
if [[ "$launcher_mode" == "window" ]]; then
  if command -v gnome-terminal >/dev/null 2>&1; then
    gnome-terminal -- bash -lc "'${runner_file}'"
  elif command -v x-terminal-emulator >/dev/null 2>&1; then
    x-terminal-emulator -e "${runner_file}"
  else
    echo "Error: no terminal emulator found for window launcher." >&2
    exit 2
  fi
else
  nohup "$runner_file" >/dev/null 2>&1 &
fi

append_fleet_registry

auto_monitor_active=0
monitor_log_file="$RUN_DIR/${run_id}.monitor.log"
monitor_pid_file="$RUN_DIR/${run_id}.monitor.pid"
if (( WAIT_MODE == 0 )) && [[ "$AUTO_MONITOR" == "1" ]]; then
  if [[ -x "$MONITOR_SCRIPT" ]]; then
    monitor_cmd=(
      "$MONITOR_SCRIPT"
      --run-dir "$RUN_DIR"
      --run-id "$run_id"
      --label "spawn_second_agent"
      --poll-sec "$AUTO_MONITOR_POLL_SEC"
      --heartbeat-sec "$AUTO_MONITOR_HEARTBEAT_SEC"
      --timeout-sec "$AUTO_MONITOR_TIMEOUT_SEC"
      --pid-file "$monitor_pid_file"
      --monitor-log "$monitor_log_file"
    )
    if [[ "$AUTO_MONITOR_STDOUT" == "1" ]]; then
      monitor_cmd+=(--stdout)
    fi
    rm -f "$monitor_pid_file" >/dev/null 2>&1 || true
    if command -v setsid >/dev/null 2>&1; then
      setsid -f "${monitor_cmd[@]}" >/dev/null 2>&1 < /dev/null || true
    else
      nohup "${monitor_cmd[@]}" >/dev/null 2>&1 &
    fi
    monitor_pid=""
    for _ in 1 2 3 4 5; do
      if [[ -s "$monitor_pid_file" ]]; then
        monitor_pid="$(tr -d '[:space:]' <"$monitor_pid_file" 2>/dev/null || true)"
        break
      fi
      sleep 0.1
    done
    if [[ -n "$monitor_pid" ]] && kill -0 "$monitor_pid" >/dev/null 2>&1; then
      auto_monitor_active=1
    else
      auto_monitor_active=0
      echo "W_AUTO_MONITOR_DISABLED reason=monitor_not_running run_id=${run_id}" >&2
    fi
  else
    monitor_log_file=""
    monitor_pid_file=""
    echo "W_AUTO_MONITOR_DISABLED reason=monitor_script_missing path=${MONITOR_SCRIPT}" >&2
  fi
fi

echo "RUN_ID=${run_id}"
echo "CHILD_RUN_ID=${run_id}"
echo "CHILD_RUN_DIR=${RUN_DIR}"
echo "LAUNCHER=${launcher_mode}"
echo "BROWSER_MODE=${BROWSER_MODE}"
echo "BROWSER_POLICY=${BROWSER_POLICY}"
echo "OPEN_BROWSER_EFFECTIVE=${OPEN_BROWSER}"
echo "INIT_SPECIALIST_CHAT=${INIT_SPECIALIST_CHAT}"
echo "AGENT_ID=${AGENT_ID:-}"
echo "AGENT_NAME=${AGENT_NAME:-}"
echo "TEAM_GOAL=${TEAM_GOAL:-}"
echo "TEAM_PEERS_COUNT=${#TEAM_PEERS[@]}"
echo "PROJECT_PATH=${PROJECT_PATH}"
echo "STATE_ROOT=${STATE_ROOT}"
echo "CODEX_CHATGPT_SEND_ROOT=${CODEX_CHATGPT_SEND_ROOT}"
echo "PROFILE_DIR=${CHILD_PROFILE_DIR}"
echo "CDP_PORT=${CDP_PORT}"
echo "LOG_FILE=${log_file}"
echo "LAST_FILE=${last_file}"
echo "STATUS_FILE=${status_file}"
echo "EXIT_FILE=${exit_file}"
echo "PID_FILE=${pid_file}"
echo "CHILD_RESULT_JSON=${child_result_file}"
echo "CHILD_CHATGPT_SEND_LOG_DIR=${CHATGPT_SEND_CHILD_LOG_DIR}"
echo "AUTO_MONITOR=${auto_monitor_active}"
echo "MONITOR_LOG_FILE=${monitor_log_file:-none}"
echo "MONITOR_PID_FILE=${monitor_pid_file:-none}"

if (( WAIT_MODE == 1 )); then
  deadline=$(( $(date +%s) + TIMEOUT_SEC ))
  while [[ ! -f "$exit_file" ]]; do
    if (( $(date +%s) >= deadline )); then
      echo "Error: wait timeout (${TIMEOUT_SEC}s) exceeded." >&2
      exit 124
    fi
    sleep 1
  done
  st="$(cat "$exit_file" | tr -d '[:space:]')"
  result=""
  if [[ -f "$last_file" ]]; then
    result="$(grep -E '^CHILD_RESULT:' "$last_file" | tail -n 1 || true)"
    if [[ -z "${result:-}" ]]; then
      result="$(tail -n 1 "$last_file" || true)"
    fi
  fi
  echo "CHILD_STATUS=${st:-unknown}"
  echo "CHILD_RESULT=${result}"
  if [[ "${st:-1}" != "0" ]]; then
    # Browser policy failures are strict and must fail the launch.
    if [[ "${st:-1}" == "41" || "${st:-1}" == "42" || "${st:-1}" == "43" || "${st:-1}" == "44" || "${st:-1}" == "45" ]]; then
      echo "CHILD_STATUS_NOTE=browser_policy_failed"
      exit "${st:-1}"
    fi
    # Codex may occasionally finish with non-zero due local recorder/shutdown issues
    # while still producing a valid final message. In that case, keep it usable.
    if [[ -n "${result:-}" ]]; then
      echo "CHILD_STATUS_NOTE=non_zero_exit_but_result_captured"
      exit 0
    fi
    exit "${st:-1}"
  fi
fi
